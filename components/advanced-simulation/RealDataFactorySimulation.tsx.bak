// @ts-nocheck
'use client'

import { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { useFactory } from '@/contexts/factory-context';
import { useSimulation } from '@/contexts/simulation-context';
import { useRouter } from 'next/navigation';
import { getAdvancedSimulationData } from '@/app/actions/advanced-simulation.actions';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Play, Pause, Square, RefreshCw, Settings, Plus, Clock, Trash2, BarChart3, ArrowLeft } from 'lucide-react';
import { toast } from 'sonner';
import {
  ReactFlow,
  Node, 
  Edge, 
  Background, 
  Controls, 
  MiniMap,
  useNodesState,
  useEdgesState,
  Position
} from '@xyflow/react';
import { PhaseNode } from './nodes/PhaseNode'
import '@xyflow/react/dist/style.css';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer
} from 'recharts';

interface SimulationStation {
  id: string;
  name: string;
  type: 'MAIN' | 'SUB';
  phase?: string;
  processingTime: number; // in minutes
  stochasticVariation: number; // percentage (0-1)
  currentOrder: SimulationOrder | null; // Only one order at a time
  waitingQueue: SimulationOrder[]; // Orders waiting for this station
  baugruppentypId?: string;
  parent?: string;
  capacity: number; // Maximum 1 for realistic simulation
}

interface SimulationOrder {
  id: string;
  kundeId: string;
  kundeName: string;
  produktvariante: string;
  currentStation: string;
  progress: number;
  startTime: Date;
  stationStartTime?: Date;
  processSequence: string[];
  requiredBaugruppentypen: string[];
  requiredUpgrades: { [baugruppentypId: string]: 'PFLICHT' | 'WUNSCH' };
  stationDurations: { [stationId: string]: { expected: number; actual?: number; startTime?: Date; completed?: boolean; waitingTime?: number } };
  isWaiting: boolean;
  completedAt?: Date;
  processSequences?: any; // JSON data from database containing all possible sequences
  selectedSequence?: any; // The randomly selected sequence for this order
  currentSequenceStep?: number; // Current step index in the selected sequence
}

// Scheduling algorithms enum and interface
enum SchedulingAlgorithm {
  FIFO = 'FIFO',
  SJF = 'SJF', // Shortest Job First
  LJF = 'LJF', // Longest Job First  
  PRIORITY = 'PRIORITY',
  EDD = 'EDD', // Earliest Due Date
  RANDOM = 'RANDOM'
}

interface SchedulingStrategy {
  name: string;
  description: string;
  selectNext: (waitingQueue: SimulationOrder[], currentTime: Date) => SimulationOrder | null;
}

import { AdvancedKPIDashboard } from './AdvancedKPIDashboard';

export function RealDataFactorySimulation() {
  const { activeFactory } = useFactory();
  const { 
    addCompletedOrder, 
    activeOrders,
    setActiveOrders, 
    stations,
    setStations: setContextStations, 
    setSimulationStartTime,
    simulationStartTime,
    isRunning,
    setIsRunning,
    speed,
    setSpeed,
    simulationTime,
    setSimulationTime,
    completedOrders,
    waitingOrders,
    setWaitingOrders,
    currentSchedulingAlgorithm,
    setCurrentSchedulingAlgorithm
  } = useSimulation();
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const lastRealTimeRef = useRef(Date.now());
  const simulationStartTimeRef = useRef<Date | null>(simulationStartTime);
  const simulationTimeRef = useRef<Date>(simulationTime);

  // Keep refs in sync with state
  useEffect(() => {
    simulationStartTimeRef.current = simulationStartTime;
  }, [simulationStartTime]);

  useEffect(() => {
    simulationTimeRef.current = simulationTime;
  }, [simulationTime]);
  
  // Local simulation data
  const [localStations, setLocalStations] = useState<SimulationStation[]>([]);
  const [factoryData, setFactoryData] = useState<any>(null);
  
  // Phase capacity & flexibility controls
  const [demSlots, setDemSlots] = useState<number>(4)
  const [monSlots, setMonSlots] = useState<number>(6)
  const [demFlexSharePct, setDemFlexSharePct] = useState<number>(50)
  const [monFlexSharePct, setMonFlexSharePct] = useState<number>(50)
  const [setupTimeHours, setSetupTimeHours] = useState<number>(0)
  const [aggregateView] = useState<boolean>(true)
  const [initDebugLogs, setInitDebugLogs] = useState<string[]>([])
  const [initError, setInitError] = useState<string | null>(null)
  const [dispatcherLogs, setDispatcherLogs] = useState<string[]>([])
  const dispatcherLogsRef = useRef<string[]>([])
  const [pickSlotDebugLogs, setPickSlotDebugLogs] = useState<string[]>([])
  const pickSlotDebugLogsRef = useRef<string[]>([])

  // Gantt chart hover states
  const [hoveredOrderRow, setHoveredOrderRow] = useState<string | null>(null)
  const [hoveredDemSlot, setHoveredDemSlot] = useState<number | null>(null)
  const [hoveredMonSlot, setHoveredMonSlot] = useState<number | null>(null)

  // Phase slot state (approximation of rigid/flexible slots)
  type SlotState = { flex: boolean; specialization?: string | null; currentType?: string | null; idleSince?: number | null; busy?: boolean }
  const demSlotsRef = useRef<SlotState[]>([])
  const monSlotsRef = useRef<SlotState[]>([])
  // Map orderId+phase -> slot index
  const orderPhaseSlotMapRef = useRef<Record<string, number>>({})

  const normalizeOperationKey = (value?: string | null) => {
  if (!value) return ''
  const str = value
    .toString()
    .replace(/^demontage[-\s]+/i, '')
    .replace(/^montage[-\s]+/i, '')
    .replace(/^bgt-(?:ps|au|vw)-/i, '')
    .replace(/^bgt-/i, '')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase()

  if (str.includes(':')) {
    const parts = str.split(':')
    return parts[parts.length - 1].trim()
  }
  if (str.includes('-')) {
    const parts = str.split('-')
    return parts[parts.length - 1].trim()
  }
  return str
}

  // Helper: minutes since simulation start
  const getSimMinutes = useCallback(() => {
    if (!simulationStartTimeRef.current) return 0
    const diffMs = simulationTimeRef.current.getTime() - simulationStartTimeRef.current.getTime()
    return Math.max(0, Math.floor(diffMs / 60000))
  }, [])

  // Initialize slots based on current used types
  const initPhaseSlots = useCallback((usedDemTypes: string[], usedMonTypes: string[]) => {
    const makeSlots = (total: number, flexSharePct: number, usedTypes: string[]) => {
      const flexCount = Math.max(0, Math.round((flexSharePct / 100) * total))
      const rigidCount = Math.max(0, total - flexCount)
      // Determine rigid specializations from top types
      const counts: Record<string, number> = {}
      usedTypes.forEach(t => { counts[t] = (counts[t] || 0) + 1 })
      const topTypes = Object.entries(counts).sort((a,b)=>b[1]-a[1]).map(([t])=>t)
      const slots: SlotState[] = []
      for (let i=0;i<rigidCount;i++) {
        const specRaw = topTypes.length ? topTypes[i % topTypes.length] : (usedTypes[0] || null)
        const spec = specRaw ? normalizeOperationKey(specRaw) : null
        slots.push({ flex: false, specialization: spec, currentType: null, idleSince: 0, busy: false })
      }
      for (let i=0;i<flexCount;i++) {
        slots.push({ flex: true, specialization: null, currentType: null, idleSince: null, busy: false })
      }
      return slots
    }
    demSlotsRef.current = makeSlots(demSlots, demFlexSharePct, usedDemTypes)
    monSlotsRef.current = makeSlots(monSlots, monFlexSharePct, usedMonTypes)
    orderPhaseSlotMapRef.current = {}
  }, [demSlots, monSlots, demFlexSharePct, monFlexSharePct])

  // Pick a slot for a given phase and op type (returns slot index or -1)
  const pickSlot = useCallback((phase: 'DEMONTAGE'|'REASSEMBLY', opType: string) => {
    const slots = phase === 'DEMONTAGE' ? demSlotsRef.current : monSlotsRef.current
    const nowMin = getSimMinutes()
    const setupMinutes = Math.max(0, Math.round(setupTimeHours * 60))
    const desiredKey = normalizeOperationKey(opType)

    pickSlotDebugLogsRef.current = []
    pickSlotDebugLogsRef.current.push(`🎯 pickSlot: phase=${phase} opType=${opType} desiredKey=${desiredKey} setupMin=${setupMinutes} nowMin=${nowMin}`)

    for (let i = 0; i < slots.length; i++) {
      const slot = slots[i]
      pickSlotDebugLogsRef.current.push(`  S${i}: busy=${slot.busy} flex=${slot.flex} spec=${slot.specialization} currType=${slot.currentType} idleSince=${slot.idleSince}`)

      if (slot.busy) {
        pickSlotDebugLogsRef.current.push(`    ❌ skip: busy`)
        continue
      }

      const slotSpecKey = normalizeOperationKey(slot.specialization)
      const slotCurrentKey = normalizeOperationKey(slot.currentType)
      pickSlotDebugLogsRef.current.push(`    specKey=${slotSpecKey} currentKey=${slotCurrentKey}`)

      if (!slot.flex) {
        pickSlotDebugLogsRef.current.push(`    rigid slot`)
        if (desiredKey && slotSpecKey !== desiredKey) {
          pickSlotDebugLogsRef.current.push(`    ❌ skip: rigid mismatch (${slotSpecKey} !== ${desiredKey})`)
          continue
        }
        pickSlotDebugLogsRef.current.push(`    ✅ MATCH rigid slot!`)
        slot.busy = true
        slot.currentType = opType
        slot.idleSince = null
        return i
      }

      const sameOrUnassigned = !slot.currentType || slotCurrentKey === desiredKey || !desiredKey
      pickSlotDebugLogsRef.current.push(`    flex slot: sameOrUnassigned=${sameOrUnassigned} (!currType=${!slot.currentType} || match=${slotCurrentKey === desiredKey} || !desired=${!desiredKey})`)
      if (sameOrUnassigned) {
        pickSlotDebugLogsRef.current.push(`    ✅ MATCH flex slot (same/unassigned)!`)
        slot.busy = true
        slot.currentType = opType
        slot.idleSince = null
        return i
      }

      const idleSince = slot.idleSince == null ? nowMin : slot.idleSince
      const idleDuration = Math.max(0, nowMin - idleSince)
      pickSlotDebugLogsRef.current.push(`    idleSince=${idleSince} idleDuration=${idleDuration} setupMinutes=${setupMinutes}`)

      if (idleDuration >= setupMinutes) {
        pickSlotDebugLogsRef.current.push(`    ✅ MATCH flex slot (setup elapsed)!`)
        slot.busy = true
        slot.currentType = opType
        slot.idleSince = null
        return i
      }
      pickSlotDebugLogsRef.current.push(`    ❌ skip: setup not elapsed (${idleDuration} < ${setupMinutes})`)
    }

    pickSlotDebugLogsRef.current.push(`  ❌ NO SLOT FOUND`)
    return -1
  }, [getSimMinutes, setupTimeHours])

  const releaseSlot = useCallback((phase: 'DEMONTAGE'|'REASSEMBLY', slotIdx: number) => {
    const slots = phase === 'DEMONTAGE' ? demSlotsRef.current : monSlotsRef.current
    const s = slots[slotIdx]
    if (!s) return
    s.busy = false
    s.idleSince = getSimMinutes()
  }, [getSimMinutes])
  
  
  // View state for simulation vs data dashboard
  const [currentView, setCurrentView] = useState<'simulation' | 'kpi'>('simulation');
  
  // No local scheduling configuration - using context
  
  
  // Scheduling strategies implementation
  const schedulingStrategies: { [key in SchedulingAlgorithm]: SchedulingStrategy } = {
    [SchedulingAlgorithm.FIFO]: {
      name: 'First In First Out',
      description: 'Ordnung nach Ankunftsreihenfolge',
      selectNext: (waitingQueue: SimulationOrder[]) => waitingQueue.length > 0 ? waitingQueue[0] : null
    },
    [SchedulingAlgorithm.SJF]: {
      name: 'Shortest Job First',
      description: 'Kürzeste Bearbeitungszeit zuerst',
      selectNext: (waitingQueue: SimulationOrder[], currentTime: Date) => {
        if (waitingQueue.length === 0) return null;
        return waitingQueue.reduce((shortest, order) => {
          const shortestTime = Object.values(shortest.stationDurations).reduce((sum, d) => sum + d.expected, 0);
          const orderTime = Object.values(order.stationDurations).reduce((sum, d) => sum + d.expected, 0);
          return orderTime < shortestTime ? order : shortest;
        });
      }
    },
    [SchedulingAlgorithm.LJF]: {
      name: 'Longest Job First',
      description: 'Längste Bearbeitungszeit zuerst',
      selectNext: (waitingQueue: SimulationOrder[], currentTime: Date) => {
        if (waitingQueue.length === 0) return null;
        return waitingQueue.reduce((longest, order) => {
          const longestTime = Object.values(longest.stationDurations).reduce((sum, d) => sum + d.expected, 0);
          const orderTime = Object.values(order.stationDurations).reduce((sum, d) => sum + d.expected, 0);
          return orderTime > longestTime ? order : longest;
        });
      }
    },
    [SchedulingAlgorithm.PRIORITY]: {
      name: 'Priority Scheduling',
      description: 'Priorität basierend auf Kundentyp',
      selectNext: (waitingQueue: SimulationOrder[]) => {
        if (waitingQueue.length === 0) return null;
        // Simple priority based on customer name (Premium customers first)
        return waitingQueue.find(order => order.kundeName.toLowerCase().includes('premium')) || waitingQueue[0];
      }
    },
    [SchedulingAlgorithm.EDD]: {
      name: 'Earliest Due Date',
      description: 'Früheste Liefertermin zuerst',
      selectNext: (waitingQueue: SimulationOrder[]) => {
        if (waitingQueue.length === 0) return null;
        return waitingQueue.reduce((earliest, order) => 
          order.startTime < earliest.startTime ? order : earliest
        );
      }
    },
    [SchedulingAlgorithm.RANDOM]: {
      name: 'Random Selection',
      description: 'Zufällige Auswahl aus Warteschlange',
      selectNext: (waitingQueue: SimulationOrder[]) => {
        if (waitingQueue.length === 0) return null;
        const randomIndex = Math.floor(Math.random() * waitingQueue.length);
        return waitingQueue[randomIndex];
      }
    }
  };
  
  // Flow diagram nodes and edges
  const [nodes, setNodes, onNodesChange] = useNodesState<Node>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState<Edge>([]);

  // Custom node types for React Flow
  const nodeTypes = useMemo(() => ({ phaseNode: PhaseNode }), []);

  // Station configuration dialog
  const [selectedStation, setSelectedStation] = useState<SimulationStation | null>(null);
  const [stationDialogOpen, setStationDialogOpen] = useState(false);
  const [tempProcessingTime, setTempProcessingTime] = useState(0);
  
  // Inspection settings
  const [inspectionDialogOpen, setInspectionDialogOpen] = useState(false);
  const [reassemblyPercentage, setReassemblyPercentage] = useState(25); // Default 25% need reassembly

  // Local event log for Gantt (START/END of sub-ops)
  const simEventsRef = useRef<Array<{ t:number; order_id:string; activity:string; slot?: number | null }>>([])
  const pushEvent = useCallback((activity: string, orderId: string, slot?: number | null) => {
    simEventsRef.current.push({ t: getSimMinutes(), order_id: orderId, activity, slot: (slot ?? null) })
  }, [getSimMinutes])

  // Main phase active trackers to enforce capacity=1
  const mainActiveRef = useRef<{ [stationId: string]: { orderId: string; remaining: number; total: number } | null }>({})

  // Gantt refresh gating: re-render every 10 minutes of simulation time
  const [ganttRefreshKey, setGanttRefreshKey] = useState(0)
  const lastGanttBucketRef = useRef<number>(-1)
  const [debugRefreshKey, setDebugRefreshKey] = useState(0)
  useEffect(() => {
    const min = getSimMinutes()
    const bucket = Math.floor(min / 10)
    if (bucket !== lastGanttBucketRef.current) {
      lastGanttBucketRef.current = bucket
      setGanttRefreshKey(k => k + 1)
    }
    // Refresh debug panel every second (in real time)
    const debugInterval = setInterval(() => {
      if (isRunning) {
        setDebugRefreshKey(k => k + 1)
      }
    }, 1000)
    return () => clearInterval(debugInterval)
  }, [simulationTime, getSimMinutes, isRunning])

  // Main phase queues and DEM ready gating
  const mainQueuesRef = useRef<{ acceptance: string[]; inspection: string[]; demWait: string[]; quality: string[]; shipping: string[] }>({ acceptance: [], inspection: [], demWait: [], quality: [], shipping: [] })
  const demReadySetRef = useRef<Set<string>>(new Set())

  // Keep a ref mirror of activeOrders to avoid stale closures inside tight loops
  const activeOrdersRef = useRef(activeOrders)
  useEffect(() => { activeOrdersRef.current = activeOrders }, [activeOrders])

  // FCFS dispatcher data structures (aggregate mode)
  type OpItem = { label: string; duration: number; display?: string; typeKey?: string }
  type Bundle = { orderId: string; ops: OpItem[]; locked?: boolean }
  const demQueueRef = useRef<Bundle[]>([])
  const monQueueRef = useRef<Bundle[]>([])
  const demActivesRef = useRef<Array<{ orderId: string; label: string; slotIdx: number; remaining: number; total: number }>>([])
  const monActivesRef = useRef<Array<{ orderId: string; label: string; slotIdx: number; remaining: number; total: number }>>([])
  const monBundlesMapRef = useRef<Record<string, OpItem[]>>({})

  // Load factory data
  useEffect(() => {
    if (activeFactory) {
      loadSimulationData();
    }
  }, [activeFactory]);

  const loadSimulationData = async () => {
    if (!activeFactory) return;
    
    setLoading(true);
    try {
      const result = await getAdvancedSimulationData(activeFactory.id);
      
      if (result.success && result.data) {
        setFactoryData(result.data);
        
        // Initialize stations with stochastic variations and capacity limits
        const mainStations: SimulationStation[] = [
          { id: 'order-acceptance', name: 'Auftragsannahme', type: 'MAIN', phase: 'AUFTRAGSANNAHME', processingTime: 5, stochasticVariation: 0.2, currentOrder: null, waitingQueue: [], capacity: 1 },
          { id: 'inspection', name: 'Inspektion', type: 'MAIN', phase: 'INSPEKTION', processingTime: 15, stochasticVariation: 0.3, currentOrder: null, waitingQueue: [], capacity: 1 },
          { id: 'demontage-waiting', name: 'Warteschlange Demontage', type: 'MAIN', phase: 'DEMONTAGE', processingTime: 2, stochasticVariation: 0.1, currentOrder: null, waitingQueue: [], capacity: 1 },
          { id: 'demontage', name: 'Demontage', type: 'MAIN', phase: 'DEMONTAGE', processingTime: 0, stochasticVariation: 0.25, currentOrder: null, waitingQueue: [], capacity: 1 },
          { id: 'reassembly', name: 'Re-Assembly', type: 'MAIN', phase: 'REASSEMBLY', processingTime: 0, stochasticVariation: 0.25, currentOrder: null, waitingQueue: [], capacity: 1 },
          { id: 'quality', name: 'Qualitätsprüfung', type: 'MAIN', phase: 'QUALITAETSPRUEFUNG', processingTime: 20, stochasticVariation: 0.4, currentOrder: null, waitingQueue: [], capacity: 1 },
          { id: 'shipping', name: 'Versand', type: 'MAIN', phase: 'VERSAND', processingTime: 10, stochasticVariation: 0.2, currentOrder: null, waitingQueue: [], capacity: 1 }
        ];
        
        // Filter Baugruppentypen to only include those that are actually used in the process graph
        const getUsedBaugruppentypen = () => {
          if (!result.data.processSequences || result.data.processSequences.length === 0) {
            // Fallback: use all baugruppentypen if no process data
            return result.data.stations.demontageSubStations;
          }
          
          const processGraphData = result.data.processSequences[0]?.processGraphData;
          if (!processGraphData || !processGraphData.cells) {
            return result.data.stations.demontageSubStations;
          }
          
          // Find all connected nodes in the process graph
          const connectedNodeIds = new Set<string>();
          const links = processGraphData.cells.filter((cell: any) => cell.type === 'standard.Link');
          
          links.forEach((link: any) => {
            if (link.source && link.target) {
              connectedNodeIds.add(link.source.id);
              connectedNodeIds.add(link.target.id);
            }
          });
          
          // Filter nodes to only include those that are connected and have baugruppentyp
          const connectedNodes = processGraphData.cells.filter((cell: any) => 
            cell.type !== 'standard.Link' && 
            connectedNodeIds.has(cell.id) &&
            cell.baugruppentyp
          );
          
          const usedBaugruppentypIds = new Set(
            connectedNodes.map((node: any) => node.baugruppentyp.id)
          );
          
          // Filter the original sub-stations to only include used ones
          return result.data.stations.demontageSubStations.filter((sub: any) => 
            usedBaugruppentypIds.has(sub.baugruppentypId)
          );
        };
        
        const usedBaugruppentypen = getUsedBaugruppentypen();
        console.log('Used Baugruppentypen:', usedBaugruppentypen.map(b => b.name));

        // Add sub-stations for Demontage and Re-Assembly based on actually used Baugruppentypen
        const demontageSubStations: SimulationStation[] = usedBaugruppentypen.map((sub: any) => ({
          id: `demontage-${sub.id}`,
          name: sub.name,
          type: 'SUB' as const,
          parent: 'demontage',
          baugruppentypId: sub.baugruppentypId,
          processingTime: 30, // Default 30 minutes
          stochasticVariation: 0.3,
          currentOrder: null,
          waitingQueue: [],
          capacity: 1
        }));
        
        const reassemblySubStations: SimulationStation[] = usedBaugruppentypen.map((sub: any) => ({
          id: `reassembly-${sub.id}`,
          name: sub.name.replace('Demontage', 'Montage'), // Convert Demontage to Montage for reassembly stations
          type: 'SUB' as const,
          parent: 'reassembly',
          baugruppentypId: sub.baugruppentypId,
          processingTime: 45, // Default 45 minutes
          stochasticVariation: 0.25,
          currentOrder: null,
          waitingQueue: [],
          capacity: 1
        }));
        
        const allStations = [...mainStations, ...demontageSubStations, ...reassemblySubStations];
        setLocalStations(allStations);
        setContextStations(allStations);
        
        // Convert existing active orders to simulation format and assign to Auftragsannahme
        const activeOrders = result.data.orders.filter((order: any) => 
          order.phase !== 'AUFTRAGSABSCHLUSS'
        );
        
        const simulationOrders: SimulationOrder[] = activeOrders.map((order: any) => {
          const requiredBgt = extractRequiredBaugruppentypen(order);
          const requiredUpgrades = extractRequiredUpgrades(order);
          
          // Use the new function to select a random sequence and convert it
          const { processSequence: processSeq, selectedSequence } = selectRandomSequenceAndConvert(
            order, 
            [...mainStations, ...demontageSubStations, ...reassemblySubStations]
          );
          
          return {
            id: order.id,
            kundeId: order.kundeId,
            kundeName: `${order.kunde.vorname} ${order.kunde.nachname}`,
            produktvariante: order.produktvariante.bezeichnung,
            currentStation: 'order-acceptance', // All active orders start at Auftragsannahme
            progress: 0,
            startTime: new Date(order.createdAt),
            stationStartTime: new Date(),
            processSequence: processSeq,
            requiredBaugruppentypen: requiredBgt,
            requiredUpgrades: requiredUpgrades,
            stationDurations: {},
            isWaiting: false,
            processSequences: order.processSequences, // Include the JSON data from database
            selectedSequence: selectedSequence, // Store the selected sequence
            currentSequenceStep: 0 // Start at beginning of sequence
          };
        });
        
        setActiveOrders(simulationOrders);

        // Don't set simulation start time here - wait for user to press Start
        // setSimulationStartTime(new Date());
        
        // Create flow diagram after state is set
        setTimeout(() => {
          createFlowDiagram(mainStations, demontageSubStations, reassemblySubStations);
        }, 100);

        // Build FCFS queues (aggregate mode)
        try {
          // Initialize phase slots based on used types
          // Use station names instead of IDs for proper matching
          initPhaseSlots(
            demontageSubStations.map(s => normalizeOperationKey(s.name || s.baugruppentypId || '')),
            reassemblySubStations.map(s => normalizeOperationKey(s.name || s.baugruppentypId || ''))
          )
          const makeOps = (steps: string[], which: 'DEM'|'MON'): OpItem[] => {
            const ops: OpItem[] = []
            const crossIdx = steps.indexOf('×')
            const slice = which === 'DEM' ? (crossIdx >= 0 ? steps.slice(0, crossIdx) : steps) : (crossIdx >= 0 ? steps.slice(crossIdx + 1) : [])

            const findStationForStep = (collection: SimulationStation[], step: string) => {
              const normalizedStep = normalizeOperationKey(step)
              return collection.find(station => {
                const candidates = [
                  station.name,
                  station.name?.replace(/^Demontage\s+/i, '').replace(/^Montage\s+/i, ''),
                  station.baugruppentypId,
                  station.id
                ].filter(Boolean) as string[]

                return candidates.some(candidate => {
                  const normalizedCandidate = normalizeOperationKey(candidate)
                  return candidate === step || normalizedCandidate === normalizedStep
                })
              })
            }

            slice.forEach(step => {
              if (!step || step === 'I' || step === 'Q' || step === '×') return

              const station = which === 'DEM'
                ? findStationForStep(demontageSubStations, step)
                : findStationForStep(reassemblySubStations, step)

              const durationFallback = which === 'DEM' ? 30 : 45
              const baseDuration = station?.processingTime ?? durationFallback
              const variation = station?.stochasticVariation ?? 0.3
              // Apply stochastic variation
              const randomFactor = (Math.random() - 0.5) * 2 // -1 to 1
              const variationAmount = baseDuration * variation * randomFactor
              const duration = Math.max(1, Math.round(baseDuration + variationAmount))

              // Use station name for typeKey to match with slot specializations
              const rawTypeKey =
                station?.name ||
                step
              const typeKey = normalizeOperationKey(rawTypeKey)
              const displayLabel = station?.name || step

              ops.push({
                label: displayLabel,
                duration,
                display: displayLabel,
                typeKey
              })
            })

            return ops
          }

          demQueueRef.current = []
          monQueueRef.current = []
          monBundlesMapRef.current = {}
          demActivesRef.current = []
          monActivesRef.current = []

          const debugLogs: string[] = []
          console.log('=== SIMULATION INIT START ===')
          console.log('demontageSubStations:', demontageSubStations.length)
          console.log('reassemblySubStations:', reassemblySubStations.length)

          simulationOrders.forEach((simOrder: any) => {
            // prefer selectedSequence from processSequences
            let steps: string[] = []
            try {
              const ps = typeof simOrder.processSequences === 'string' ? JSON.parse(simOrder.processSequences) : simOrder.processSequences
              const seqs = ps?.baugruppentypen?.sequences
              if (Array.isArray(seqs) && seqs.length > 0) {
                // RANDOMLY select one sequence instead of always taking the first
                const randomIndex = Math.floor(Math.random() * seqs.length)
                const pick = seqs[randomIndex]
                steps = Array.isArray(pick?.steps) ? pick.steps.map((s:any)=>String(s)) : []
                console.log(`📋 Order ${simOrder.kundeName}: Randomly selected sequence ${randomIndex + 1}/${seqs.length} (${pick.id || 'no-id'}) with steps: ${steps.join(',')}`)
              }
            } catch {}
            if (steps.length === 0 && Array.isArray(simOrder.selectedSequence?.steps)) {
              steps = simOrder.selectedSequence.steps.map((s:any)=>String(s))
            }
            // FALLBACK: If no steps, create a realistic sequence from available stations
            const needsFallback = steps.length === 0 || (steps.length === 2 && steps[0] === 'I' && steps[1] === 'Q')
            if (needsFallback) {
              console.log(`🔧 FALLBACK for ${simOrder.kundeName}: demSubs=${demontageSubStations.length}, monSubs=${reassemblySubStations.length}`)
              // Use actual baugruppen from the stations
              const demSteps = demontageSubStations.slice(0, 3).map(s => s.baugruppentypId || s.name)
              const monSteps = reassemblySubStations.slice(0, 3).map(s => s.baugruppentypId || s.name)
              steps = ['I', ...demSteps, '×', ...monSteps, 'Q']
              console.log(`🔧 Generated steps:`, steps)
            }

            const demOps = makeOps(steps, 'DEM')
            const monOps = makeOps(steps, 'MON')

            // DEBUG: Log details to understand why demOps is empty
            console.log(`📦 Order ${simOrder.id.slice(-4)} (${simOrder.kundeName}):`)
            console.log('  Original steps:', steps)
            console.log('  DemOps:', demOps)
            console.log('  MonOps:', monOps)

            const stepsStr = steps.length > 5 ? `${steps.slice(0,5).join(',')}...` : steps.join(',')
            const demOpsStr = demOps.length > 0 ? demOps.map(o => o.label).join(', ') : 'NONE'
            const fallbackFlag = needsFallback ? ' [FALLBACK]' : ''
            debugLogs.push(`${simOrder.kundeName.slice(0,15)}${fallbackFlag}: steps=[${stepsStr}] → ${demOps.length} demOps`)

            if (demOps.length > 0) demQueueRef.current.push({ orderId: simOrder.id, ops: demOps })
            if (monOps.length > 0) {
              monBundlesMapRef.current[simOrder.id] = monOps
            }
          })
          setInitDebugLogs(debugLogs)

          // Show alert with summary
          const summary = `Simulation Init:\n- Orders: ${simulationOrders.length}\n- DemOps created: ${demQueueRef.current.length}\n- MonOps created: ${Object.keys(monBundlesMapRef.current).length}\n\nFirst 3 logs:\n${debugLogs.slice(0, 3).join('\n')}`
          console.log(summary)
          setTimeout(() => alert(summary), 500)

          // Initialize main phase queues: all orders start at acceptance
          mainQueuesRef.current = {
            acceptance: simulationOrders.map((o:any) => o.id),
            inspection: [],
            demWait: [],
            quality: [],
            shipping: []
          }
          demReadySetRef.current = new Set()
        } catch (e) {
          const errorMsg = `FCFS queue build error: ${e instanceof Error ? e.message : String(e)}`
          console.error(errorMsg, e)
          setInitError(errorMsg)
        }
      } else {
        toast.error(result.error || 'Fehler beim Laden der Simulationsdaten');
      }
    } catch (error) {
      console.error('Error loading simulation data:', error);
      toast.error('Fehler beim Laden der Simulationsdaten');
    } finally {
      setLoading(false);
    }
  };

  // New function to randomly select and convert a JSON sequence to simulation process sequence
  const selectRandomSequenceAndConvert = (order: any, allStations: SimulationStation[]): { processSequence: string[], selectedSequence: any } => {
    const processSequencesData = typeof order.processSequences === 'string' 
      ? JSON.parse(order.processSequences) 
      : order.processSequences;
    
    if (!processSequencesData?.baugruppentypen?.sequences || processSequencesData.baugruppentypen.sequences.length === 0) {
      // Fallback to old method if no sequences
      const requiredBgt = extractRequiredBaugruppentypen(order);
      const requiredUpgrades = extractRequiredUpgrades(order);
      return {
        processSequence: determineProcessSequenceWithUpgrades(order, allStations, requiredBgt, requiredUpgrades),
        selectedSequence: null
      };
    }
    
    // Randomly select one sequence from baugruppentypen sequences
    const sequences = processSequencesData.baugruppentypen.sequences;
    const randomIndex = Math.floor(Math.random() * sequences.length);
    const selectedSequence = sequences[randomIndex];
    
    console.log(`Order ${order.kunde.vorname} ${order.kunde.nachname}: Selected sequence ${selectedSequence.id}:`, selectedSequence.steps);
    
    // Convert the sequence steps to station IDs
    const processSequence: string[] = [];
    
    selectedSequence.steps.forEach((step: string, index: number) => {
      if (step === 'I') {
        // Inspection
        if (index === 0) {
          processSequence.push('order-acceptance', 'inspection', 'demontage-waiting');
        }
      } else if (step === '×') {
        // Quality check transition - this separates demontage from reassembly
        // No station added, just a marker in the sequence
      } else if (step === 'Q') {
        // Quality and shipping
        processSequence.push('quality', 'shipping');
      } else {
        // This is a component step - find corresponding station
        const isBeforeQuality = selectedSequence.steps.indexOf('×') > -1 && index < selectedSequence.steps.indexOf('×');
        const isAfterQuality = selectedSequence.steps.indexOf('×') > -1 && index > selectedSequence.steps.indexOf('×');
        
        if (isBeforeQuality) {
          // Demontage station
          const demontageStation = allStations.find(s => 
            s.type === 'SUB' && 
            s.parent === 'demontage' && 
            (s.name.includes(step) || s.name.includes(step.replace('BGT-PS-', '').replace('BGT-', '')))
          );
          if (demontageStation) {
            processSequence.push(demontageStation.id);
          }
        } else if (isAfterQuality) {
          // Reassembly station  
          const reassemblyStation = allStations.find(s => 
            s.type === 'SUB' && 
            s.parent === 'reassembly' && 
            (s.name.includes(step) || s.name.includes(step.replace('BGT-PS-', '').replace('BGT-', '')))
          );
          if (reassemblyStation) {
            processSequence.push(reassemblyStation.id);
          }
        }
      }
    });
    
    console.log(`Converted to process sequence:`, processSequence);
    
    return {
      processSequence,
      selectedSequence
    };
  };

  const determineProcessSequenceWithUpgrades = (order: any, allStations: SimulationStation[], requiredBgt: string[], requiredUpgrades: { [baugruppentypId: string]: 'PFLICHT' | 'WUNSCH' }): string[] => {
    const sequence = ['order-acceptance', 'inspection'];
    
    // Add demontage stations for all required Baugruppentypen (all need disassembly)
    requiredBgt.forEach(bgt => {
      const station = allStations.find(s => 
        s.type === 'SUB' && 
        s.parent === 'demontage' && 
        (s.name.includes(bgt) || s.name.includes(bgt.replace('BGT-PS-', '').replace('BGT-', '')))
      );
      if (station) {
        sequence.push(station.id);
      }
    });
    
    // Add reassembly stations only for Baugruppentypen that need PFLICHT or WUNSCH upgrades
    Object.entries(requiredUpgrades).forEach(([bgt, upgradeType]) => {
      if (upgradeType === 'PFLICHT' || upgradeType === 'WUNSCH') {
        const station = allStations.find(s => 
          s.type === 'SUB' && 
          s.parent === 'reassembly' && 
          (s.name.includes(bgt) || s.name.includes(bgt.replace('BGT-PS-', '').replace('BGT-', '')))
        );
        if (station) {
          sequence.push(station.id);
        }
      }
    });
    
    sequence.push('quality', 'shipping');
    
    // Add waiting station before disassembly operations
    return addWaitingStationBeforeDisassembly(sequence);
  };

  // Add waiting list before entering disassembly
  const addWaitingStationBeforeDisassembly = (sequence: string[]): string[] => {
    const newSequence = [...sequence];
    const inspectionIndex = sequence.indexOf('inspection');
    const demontageIndex = sequence.findIndex(s => s.includes('demontage') && s !== 'demontage-waiting');
    
    if (inspectionIndex !== -1 && demontageIndex !== -1) {
      // Insert waiting station between inspection and first disassembly
      newSequence.splice(demontageIndex, 0, 'demontage-waiting');
    }
    
    return newSequence;
  };

  // Keep old function for backward compatibility but mark as deprecated
  const determineProcessSequence = (order: any, allStations: SimulationStation[], requiredBgt: string[]): string[] => {
    console.warn('Using deprecated determineProcessSequence, should use determineProcessSequenceWithUpgrades');
    return determineProcessSequenceWithUpgrades(order, allStations, requiredBgt, {});
  };

  const extractRequiredBaugruppentypen = (order: any): string[] => {
    const bgtSet = new Set<string>();
    order.baugruppenInstances?.forEach((instance: any) => {
      if (instance.baugruppe?.baugruppentyp?.bezeichnung) {
        bgtSet.add(instance.baugruppe.baugruppentyp.bezeichnung);
      }
    });
    return Array.from(bgtSet);
  };

  const extractRequiredUpgrades = (order: any): { [baugruppentypId: string]: 'PFLICHT' | 'WUNSCH' } => {
    const upgrades: { [baugruppentypId: string]: 'PFLICHT' | 'WUNSCH' } = {};
    order.baugruppenInstances?.forEach((instance: any) => {
      if (instance.reAssemblyTyp && instance.baugruppe?.baugruppentyp?.bezeichnung) {
        upgrades[instance.baugruppe.baugruppentyp.bezeichnung] = instance.reAssemblyTyp;
      }
    });
    return upgrades;
  };

  const createFlowDiagram = (
    mainStations: SimulationStation[], 
    demontageSubStations: SimulationStation[], 
    reassemblySubStations: SimulationStation[]
  ) => {
    const flowNodes: Node[] = [];
    const flowEdges: Edge[] = [];
    
    // Calculate dynamic heights based on number of sub-stations (vertical layout)
    const demontageHeight = Math.max(350, 120 + demontageSubStations.length * 80 + 40);
    const reassemblyHeight = Math.max(350, 120 + reassemblySubStations.length * 80 + 40);
    
    // Equal spacing for main nodes
    const SPACING = 260;
    const Y = 100;
    const indexById: Record<string, number> = {
      'order-acceptance': 0,
      'inspection': 1,
      'demontage-waiting': 2,
      'quality': 5,
      'shipping': 6,
    };
    mainStations.forEach((station) => {
      const isParent = station.id === 'demontage' || station.id === 'reassembly';
      if (isParent) return;
      const idx = indexById[station.id] ?? 0;
      flowNodes.push({
        id: station.id,
        type: 'default',
        position: { x: idx * SPACING, y: Y },
        data: {
          label: (
            <div className="text-center">
              <div className="font-bold">{station.name}</div>
              <div className="text-xs text-gray-500">Zeit: {station.processingTime} min (±{Math.round(station.stochasticVariation * 100)}%)</div>
            </div>
          )
        },
        style: {
          background: '#ffffff',
          border: '2px solid #1e40af',
          borderRadius: '8px',
          padding: '10px',
          width: 180,
          height: 80
        },
        sourcePosition: Position.Right,
        targetPosition: Position.Left
      });
    });
    
    // Add sub-stations for Demontage (only if not aggregated)
    if (!aggregateView) demontageSubStations.forEach((subStation, index) => {
      const currentOrderName = subStation.currentOrder?.kundeName || 'Frei';
      const waitingCount = subStation.waitingQueue?.length || 0;
      const isOccupied = subStation.currentOrder !== null;
      
      // Vertical layout for demontage sub-stations
      let position = { 
        x: 20, // Fixed x position (left aligned)
        y: 60 + index * 80 // Vertical stacking with 80px spacing
      };
      
      // Use fixed vertical layout (no process graph positioning)
      
      flowNodes.push({
        id: subStation.id,
        type: 'default',
        position: position,
        parentId: 'demontage',
        data: {
          label: (
            <div className="text-center">
              <div className="text-xs font-bold text-gray-800">
                {subStation.name.replace('Demontage ', '')}
              </div>
              <div className={`text-xs font-medium px-1 py-0.5 rounded mt-1 ${
                isOccupied 
                  ? 'bg-red-100 text-red-800' 
                  : 'bg-green-100 text-green-800'
              }`}>
                {isOccupied ? currentOrderName : 'Frei'}
              </div>
              <div className="text-xs text-gray-600 mt-0.5">
                {subStation.processingTime}min (±{Math.round(subStation.stochasticVariation * 100)}%)
              </div>
            </div>
          )
        },
        style: {
          background: isOccupied ? '#fef2f2' : '#f0f9ff',
          border: `2px solid ${isOccupied ? '#dc2626' : '#3b82f6'}`,
          borderRadius: '8px',
          padding: '8px',
          width: 180,
          height: waitingCount > 0 ? 80 : 70,
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
        }
      });
    });
    
    // Add sub-stations for Re-Assembly (only if not aggregated)
    if (!aggregateView) reassemblySubStations.forEach((subStation, index) => {
      const currentOrderName = subStation.currentOrder?.kundeName || 'Frei';
      const waitingCount = subStation.waitingQueue?.length || 0;
      const isOccupied = subStation.currentOrder !== null;
      
      // Vertical layout for reassembly sub-stations
      let position = { 
        x: 20, // Fixed x position (left aligned)
        y: 60 + index * 80 // Vertical stacking with 80px spacing
      };
      
      // Use fixed vertical layout (no process graph positioning)
      
      flowNodes.push({
        id: subStation.id,
        type: 'default',
        position: position,
        parentId: 'reassembly',
        data: {
          label: (
            <div className="text-center">
              <div className="text-xs font-bold text-gray-800">
                {subStation.name.replace('Montage ', '')}
              </div>
              <div className={`text-xs font-medium px-1 py-0.5 rounded mt-1 ${
                isOccupied 
                  ? 'bg-red-100 text-red-800' 
                  : 'bg-green-100 text-green-800'
              }`}>
                {isOccupied ? currentOrderName : 'Frei'}
              </div>
              <div className="text-xs text-gray-600 mt-0.5">
                {subStation.processingTime}min (±{Math.round(subStation.stochasticVariation * 100)}%)
              </div>
            </div>
          )
        },
        style: {
          background: isOccupied ? '#fef2f2' : '#f0fdf4',
          border: `2px solid ${isOccupied ? '#dc2626' : '#16a34a'}`,
          borderRadius: '8px',
          padding: '8px',
          width: 180,
          height: waitingCount > 0 ? 80 : 70,
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
        }
      });
    });

    // Replace area titles with custom phase nodes using live stats
    // Place phase nodes relative to nearby main nodes (without rendering big group boxes)
    const demWaitNode = flowNodes.find(n => n.id === 'demontage-waiting')
    if (demWaitNode) {
      flowNodes.push({
        id: 'demontage-phase',
        type: 'phaseNode',
        position: { x: 3 * SPACING, y: Y },
        data: {
          title: 'Demontage',
          queue: demQueueRef.current.length || 0,
          totalSlots: demSlotsRef.current.length || 0,
          busySlots: (demSlotsRef.current.filter(s => s.busy).length) || 0,
          slots: demSlotsRef.current.map(s => ({ flex: s.flex, specialization: s.specialization || null, busy: s.busy }))
        },
        draggable: false,
        selectable: false
      } as any)
    }

    const qualityNode = flowNodes.find(n => n.id === 'quality')
    if (qualityNode) {
      flowNodes.push({
        id: 'reassembly-phase',
        type: 'phaseNode',
        position: { x: 4 * SPACING, y: Y },
        data: {
          title: 'Montage',
          queue: monQueueRef.current.length || 0,
          totalSlots: monSlotsRef.current.length || 0,
          busySlots: (monSlotsRef.current.filter(s => s.busy).length) || 0,
          slots: monSlotsRef.current.map(s => ({ flex: s.flex, specialization: s.specialization || null, busy: s.busy }))
        },
        draggable: false,
        selectable: false
      } as any)
    }
    
    // Connect all main stations with proper flow - complete process chain
    // Create connections between all main process boxes
    const mainStationIds = mainStations.map(s => s.id);
    console.log('Creating flow edges for main stations:', mainStationIds);
    
    // Verify that all required station IDs exist in flowNodes
    const existingNodeIds = flowNodes.map(n => n.id);
    console.log('Existing node IDs:', existingNodeIds);
    
    // Check if required nodes exist before creating edges
    const requiredIds = ['order-acceptance', 'inspection', 'demontage-waiting', 'demontage-phase', 'reassembly-phase', 'quality', 'shipping'];
    const missingIds = requiredIds.filter(id => !existingNodeIds.includes(id));
    if (missingIds.length > 0) {
      console.error('Missing node IDs for connections:', missingIds);
    }
    
    // Add scheduling squares (decorative, not affecting flow) - positioned in the process path
    const orderAcceptanceNode = flowNodes.find(n => n.id === 'order-acceptance');
    const inspectionNode = flowNodes.find(n => n.id === 'inspection');
    const demontageWaitingNode = flowNodes.find(n => n.id === 'demontage-waiting');
    
    if (orderAcceptanceNode) {
      // 1. Circle connector between start and Auftragsannahme
      flowNodes.push({
        id: 'circle-1',
        type: 'default',
        position: { x: orderAcceptanceNode.position.x - 100, y: orderAcceptanceNode.position.y + 35 },
        data: {
          label: ''
        },
        style: {
          background: '#ffffff',
          border: '2px solid #1a48a5',
          borderRadius: '50%',
          width: 30,
          height: 30
        },
        sourcePosition: Position.Right,
        targetPosition: Position.Left,
        draggable: false,
        selectable: false
      });
    }
    
    if (orderAcceptanceNode && inspectionNode) {
      // 2. Circle connector between Auftragsannahme and Inspektion
      const midX = (orderAcceptanceNode.position.x + 180 + inspectionNode.position.x) / 2 - 15; // Center between stations
      flowNodes.push({
        id: 'circle-2',
        type: 'default',
        position: { x: midX, y: orderAcceptanceNode.position.y + 35 },
        data: {
          label: ''
        },
        style: {
          background: '#ffffff',
          border: '2px solid #1a48a5',
          borderRadius: '50%',
          width: 30,
          height: 30
        },
        sourcePosition: Position.Right,
        targetPosition: Position.Left,
        draggable: false,
        selectable: false
      });
    }
      
    if (inspectionNode && demontageWaitingNode) {
      // 3. Circle connector between Inspektion and Demontage Waiting
      const midX = (inspectionNode.position.x + 180 + demontageWaitingNode.position.x) / 2 - 15; // Center between stations
      flowNodes.push({
        id: 'circle-3',
        type: 'default',
        position: { x: midX, y: inspectionNode.position.y + 35 },
        data: {
          label: ''
        },
        style: {
          background: '#ffffff',
          border: '2px solid #1a48a5',
          borderRadius: '50%',
          width: 30,
          height: 30
        },
        sourcePosition: Position.Right,
        targetPosition: Position.Left,
        draggable: false,
        selectable: false
      });
    }
    
    // CRITICAL: Create all main process flow connections FIRST
    // Main station connections (must be complete for simulation to work)
    const mainStationEdges = [
      { id: 'circle-1-order-acceptance', source: 'circle-1', target: 'order-acceptance' },
      { id: 'order-acceptance-circle-2', source: 'order-acceptance', target: 'circle-2' },
      { id: 'circle-2-inspection', source: 'circle-2', target: 'inspection' },
      { id: 'inspection-circle-3', source: 'inspection', target: 'circle-3' },
      { id: 'circle-3-demontage-waiting', source: 'circle-3', target: 'demontage-waiting' },
      { id: 'demontage-waiting-demontage-phase', source: 'demontage-waiting', target: 'demontage-phase' },
      { id: 'demontage-phase-reassembly-phase', source: 'demontage-phase', target: 'reassembly-phase', animated: true },
      { id: 'reassembly-phase-quality', source: 'reassembly-phase', target: 'quality' },
      { id: 'quality-shipping', source: 'quality', target: 'shipping' }
    ];

    // Get all available node IDs for validation
    const availableNodeIds = flowNodes.map(n => n.id);
    console.log('🔍 All available nodes:', availableNodeIds);
    
    // Add each main station edge with validation
    mainStationEdges.forEach(({ id, source, target, animated }) => {
      if (availableNodeIds.includes(source) && availableNodeIds.includes(target)) {
        flowEdges.push({
          id,
          source,
          target,
          type: 'smoothstep',
          style: { 
            stroke: '#1a48a5', 
            strokeWidth: animated ? 4 : 3, 
            strokeDasharray: '0' 
          },
          ...(animated && { animated: true })
        });
        console.log(`✅ Connection created: ${source} → ${target}`);
      } else {
        console.error(`❌ Missing nodes for connection ${id}: source=${source} (${availableNodeIds.includes(source)}) target=${target} (${availableNodeIds.includes(target)})`);
      }
    });
    
    
    console.log(`🎯 Final result: ${flowEdges.length} connections created for ${flowNodes.length} nodes`);
    
    setNodes(flowNodes);
    setEdges(flowEdges);
  };

  // Simulation engine - now handled in context, but we still need to process orders
  useEffect(() => {
    if (!isRunning) return;

    lastRealTimeRef.current = Date.now();

    const interval = setInterval(() => {
      const now = Date.now();
      const realTimeDelta = now - lastRealTimeRef.current;
      lastRealTimeRef.current = now;

      if (realTimeDelta <= 0) {
        return;
      }

      const deltaMinutes = (realTimeDelta / 1000) * speed;
      if (deltaMinutes <= 0) {
        return;
      }

      processOrders(deltaMinutes);
    }, 100);

    return () => clearInterval(interval);
  }, [isRunning, speed]);

  const calculateStochasticProcessingTime = (baseTime: number, variation: number): number => {
    // Apply stochastic variation using normal distribution approximation
    const randomFactor = (Math.random() - 0.5) * 2; // -1 to 1
    const variationAmount = baseTime * variation * randomFactor;
    return Math.max(1, baseTime + variationAmount); // Minimum 1 minute
  };

  const saveStationDuration = async (orderId: string, stationId: string, stationName: string, stationType: string, expectedDuration: number, actualDuration: number, startTime: Date, endTime: Date) => {
    try {
      await fetch('/api/station-duration', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          auftragId: orderId,
          stationId,
          stationName,
          stationType,
          expectedDuration,
          actualDuration,
          stochasticVariation: (actualDuration - expectedDuration) / expectedDuration,
          startedAt: startTime.toISOString(),
          completedAt: endTime.toISOString()
        })
      });
    } catch (error) {
      console.error('Error saving station duration:', error);
    }
  };

  const processOrders = (deltaMinutes: number) => {
    setContextStations((prevStations: any) => {
      const updatedStations = [...prevStations];
      const newCompletedOrders: SimulationOrder[] = [];
      const updatedOrders: SimulationOrder[] = [];
      const waitingOrdersList: SimulationOrder[] = [];
      
      // Aggregate dispatcher mode (FCFS sequential per phase)
      if (aggregateView) {
        const queueQualityPhase = (orderId: string) => {
          // Note: demReadySetRef cleanup is now done in the phase completion logic
          const alreadyQueued = mainQueuesRef.current.quality.includes(orderId);
          const activeAtQuality = mainActiveRef.current['quality']?.orderId === orderId;
          if (!alreadyQueued && !activeAtQuality) {
            mainQueuesRef.current.quality.push(orderId);
          }
          setActiveOrders(prev =>
            prev.map(o =>
              o.id === orderId
                ? { ...o, currentStation: 'quality', isWaiting: true, progress: 0 }
                : o
            )
          );
        };

        const markWaitingForReassembly = (orderId: string) => {
          setActiveOrders(prev =>
            prev.map(o =>
              o.id === orderId
                ? { ...o, currentStation: 'reassembly', isWaiting: true, progress: 0 }
                : o
            )
          );
        };

        // Keep acceptance queue scoped to orders that are actually waiting for this phase
        mainQueuesRef.current.acceptance = mainQueuesRef.current.acceptance.filter(orderId => {
          const order = activeOrdersRef.current.find(o => o.id === orderId)
          return order && !order.completedAt && order.currentStation === 'order-acceptance'
        })
        activeOrdersRef.current.forEach(order => {
          if (order.completedAt) return
          if (order.currentStation !== 'order-acceptance') return
          if (mainActiveRef.current['order-acceptance']?.orderId === order.id) return
          if (!mainQueuesRef.current.acceptance.includes(order.id)) {
            mainQueuesRef.current.acceptance.push(order.id)
          }
        })
        // Capacity=1 for main phases using active tracker per station
        const processMainStation = (stationId: string) => {
          const station = updatedStations.find(s => s.id === stationId)
          if (!station) return
          const expected = station.processingTime || 1
          const active = mainActiveRef.current[stationId]

          if (active) {
            // progress active order
            active.remaining = Math.max(0, active.remaining - deltaMinutes)
            setActiveOrders(prev => prev.map(o => {
              if (o.id !== active.orderId) return o
              const sd = { ...(o.stationDurations || {}) }
              const e = sd[stationId] || {}
              sd[stationId] = { ...e, expected, actual: expected, startTime: e.startTime || new Date(), completed: active.remaining <= 0 }
              return { ...o, currentStation: stationId, progress: Math.max(0, (active.total - active.remaining)), stationDurations: sd }
            }))
            // reflect in flow node (occupancy)
            station.currentOrder = activeOrders.find(o => o.id === active.orderId) as any
            const waiters = activeOrders.filter(o => o.currentStation === stationId && o.id !== active.orderId)
            station.waitingQueue = waiters as any
            if (active.remaining <= 0) {
              // finished
              const finishedOrderId = active.orderId
              mainActiveRef.current[stationId] = null
              // Gantt END
              const phaseLbl = stationId === 'order-acceptance' ? 'ACCEPTANCE' : stationId === 'inspection' ? 'INSPECTION' : stationId === 'demontage-waiting' ? 'DEM_WAIT' : stationId === 'quality' ? 'QA' : stationId === 'shipping' ? 'SHIPPING' : stationId.toUpperCase()
              pushEvent(`${phaseLbl}:${phaseLbl}_END`, finishedOrderId, null)
              // advance order to next logical station
              const enqueueUnique = (queue: string[], orderId: string) => {
                if (!queue.includes(orderId)) {
                  queue.push(orderId)
                }
              }

              setActiveOrders(prev => prev.map(o => {
                if (o.id !== finishedOrderId) return o
                if (stationId === 'order-acceptance') {
                  enqueueUnique(mainQueuesRef.current.inspection, finishedOrderId)
                  return { ...o, currentStation: 'inspection', isWaiting: true, progress: 0 }
                }
                if (stationId === 'inspection') {
                  enqueueUnique(mainQueuesRef.current.demWait, finishedOrderId)
                  return { ...o, currentStation: 'demontage-waiting', isWaiting: true, progress: 0 }
                }
                if (stationId === 'demontage-waiting') {
                  demReadySetRef.current.add(finishedOrderId)
                  return { ...o, currentStation: 'demontage', isWaiting: true, progress: 0 }
                }
                if (stationId === 'quality') {
                  enqueueUnique(mainQueuesRef.current.shipping, finishedOrderId)
                  return { ...o, currentStation: 'shipping', isWaiting: true, progress: 0 }
                }
                if (stationId === 'shipping') {
                  return { ...o, currentStation: 'shipping', isWaiting: false, completedAt: new Date() }
                }
                return { ...o }
              }))
              // shipping completion to KPI
              if (stationId === 'shipping') {
              const ord = activeOrdersRef.current.find(o => o.id === finishedOrderId)
                if (ord) {
                  const done = { ...ord, completedAt: new Date(), schedulingAlgorithm: currentSchedulingAlgorithm }
                  newCompletedOrders.push(done as any)
                  addCompletedOrder(done as any)
                }
              }
            }
            return
          }

          // find next order from queue
          const q = stationId === 'order-acceptance' ? mainQueuesRef.current.acceptance
                    : stationId === 'inspection' ? mainQueuesRef.current.inspection
                    : stationId === 'demontage-waiting' ? mainQueuesRef.current.demWait
                    : stationId === 'quality' ? mainQueuesRef.current.quality
                    : stationId === 'shipping' ? mainQueuesRef.current.shipping : []
          const nextId = q.shift()
          if (nextId) {
            const next = activeOrdersRef.current.find(o => o.id === nextId)
            if (!next) return
            // initialize and hold capacity
            mainActiveRef.current[stationId] = { orderId: next.id, remaining: expected, total: expected }
            // ensure stationDurations entry exists
            setActiveOrders(prev => prev.map(o => {
              if (o.id !== next.id) return o
              const sd = { ...(o.stationDurations || {}) }
              sd[stationId] = sd[stationId] || { expected, actual: expected, startTime: new Date(), completed: false }
              return { ...o, currentStation: stationId, progress: 0, stationDurations: sd }
            }))
            // reflect occupancy in flow node
            station.currentOrder = next as any
            station.waitingQueue = [] as any
            // Gantt START
            const phaseLbl = stationId === 'order-acceptance' ? 'ACCEPTANCE' : stationId === 'inspection' ? 'INSPECTION' : stationId === 'demontage-waiting' ? 'DEM_WAIT' : stationId === 'quality' ? 'QA' : stationId === 'shipping' ? 'SHIPPING' : stationId.toUpperCase()
            pushEvent(`${phaseLbl}:${phaseLbl}_START`, next.id, null)
          }
        }

        // process main phases sequentially by station
        ;['order-acceptance','inspection','demontage-waiting','quality','shipping'].forEach(processMainStation)

        const nowMin = getSimMinutes()
        // helper to update main nodes' queues count
        const setPhaseQueueLen = (phaseId: 'demontage'|'reassembly', len: number) => {
          const node = updatedStations.find(s => s.id === phaseId)
          if (node) node.waitingQueue = Array.from({length: Math.max(0,len)}, ()=>({}))
        }

        const tickPhase = (phase: 'DEM'|'MON') => {
          const queueRef = phase === 'DEM' ? demQueueRef : monQueueRef
          const activesRef = phase === 'DEM' ? demActivesRef : monActivesRef
          const mainId = phase === 'DEM' ? 'demontage' : 'reassembly'

          // DEBUG: Log tickPhase calls
          if (phase === 'DEM') {
            const msg = `🔄 tickPhase ${phase} @t=${getSimMinutes()} queue=${queueRef.current.length} active=${activesRef.current.length} startTimeRef=${simulationStartTimeRef.current ? 'SET' : 'NULL'}`
            console.log(msg)
            dispatcherLogsRef.current.push(msg)
            if (dispatcherLogsRef.current.length > 50) dispatcherLogsRef.current.shift()
          }

          // Progress and sync UI for all actives
          activesRef.current = activesRef.current.map(a => ({ ...a, remaining: Math.max(0, a.remaining - deltaMinutes) }))
          const mainStation = updatedStations.find(s => s.id === mainId)
          activesRef.current.forEach((a, idx) => {
            const progress = Math.max(0, a.total - a.remaining)
            setActiveOrders(prev => prev.map(o => {
              if (o.id !== a.orderId) return o
              const sd = { ...(o.stationDurations || {}) }
              const e = sd[mainId] || {}
              sd[mainId] = { ...e, expected: a.total, actual: a.total, startTime: e.startTime || new Date(), completed: a.remaining <= 0 }
              return { ...o, currentStation: mainId, progress, stationDurations: sd, isWaiting: false }
            }))
            if (idx === 0 && mainStation) {
              mainStation.currentOrder = activeOrdersRef.current.find(o => o.id === a.orderId) as any
            }
          })

          // Complete finished actives
          const finished = activesRef.current.filter(a => a.remaining <= 0)
          if (finished.length) {
            finished.forEach(a => {
              pushEvent(`${phase === 'DEM' ? 'DEMONTAGE' : 'MONTAGE'}:${a.label}_END`, a.orderId, a.slotIdx)
              releaseSlot(phase === 'DEM' ? 'DEMONTAGE' : 'REASSEMBLY', a.slotIdx)
              delete orderPhaseSlotMapRef.current[`${a.orderId}:${phase === 'DEM' ? 'demontage-' : 'reassembly-'}`]
              const idx = queueRef.current.findIndex(b => b.orderId === a.orderId)
              if (idx >= 0) {
                const b = queueRef.current[idx]
                if (b.ops[0]?.label === a.label) b.ops.shift()
                // Only remove from queue and move to next phase when ALL ops are done
                if (b.ops.length === 0) {
                  queueRef.current.splice(idx, 1)
                  if (phase === 'DEM') {
                    // Remove from demReady only when ALL demOps are done
                    demReadySetRef.current.delete(a.orderId)
                    const monOps = monBundlesMapRef.current[a.orderId] || []
                    if (monOps.length) {
                      const alreadyQueued = monQueueRef.current.some(bundle => bundle.orderId === a.orderId)
                      if (!alreadyQueued) {
                        monQueueRef.current.push({ orderId: a.orderId, ops: [...monOps] })
                        markWaitingForReassembly(a.orderId)
                      }
                    } else {
                      queueQualityPhase(a.orderId)
                    }
                    delete monBundlesMapRef.current[a.orderId]
                  } else {
                    queueQualityPhase(a.orderId)
                    delete monBundlesMapRef.current[a.orderId]
                  }
                }
              }
            })
            activesRef.current = activesRef.current.filter(a => a.remaining > 0)
          }

          // Start new ops up to free slots by scanning queue
          for (let i = 0; i < queueRef.current.length; i++) {
            const b = queueRef.current[i]
            if (!b.ops || b.ops.length === 0) continue
            // DEM gating: only start orders that passed demontage-waiting
            if (phase === 'DEM' && !demReadySetRef.current.has(b.orderId)) {
              const msg = `⚠️ skip ${b.orderId.slice(-4)} - not in demReadySet`
              console.log(msg)
              dispatcherLogsRef.current.push(msg)
              continue
            }
            const nxt = b.ops[0]
            const desiredKey = nxt.typeKey || normalizeOperationKey(nxt.label)
            const msg1 = `🔍 try ${b.orderId.slice(-4)} op=${nxt.label} key=${desiredKey} @t=${getSimMinutes()}`
            console.log(msg1)
            dispatcherLogsRef.current.push(msg1)
            if (dispatcherLogsRef.current.length > 50) dispatcherLogsRef.current.shift()
            const slotIdx = pickSlot(
              phase === 'DEM' ? 'DEMONTAGE' : 'REASSEMBLY',
              desiredKey
            )
            const msg2 = `🎰 pickSlot result: ${slotIdx}`
            console.log(msg2)
            dispatcherLogsRef.current.push(msg2)
            if (slotIdx >= 0) {
              const displayLabel = nxt.display || nxt.label

              // IMPORTANT: Release previous slot if this order already had one in this phase
              const phaseKey = `${b.orderId}:${phase === 'DEM' ? 'demontage-' : 'reassembly-'}`
              const previousSlot = orderPhaseSlotMapRef.current[phaseKey]
              if (previousSlot !== undefined && previousSlot !== slotIdx) {
                console.log(`🔓 Releasing previous slot ${previousSlot} for order ${b.orderId.slice(-4)} before assigning new slot ${slotIdx}`)
                releaseSlot(phase === 'DEM' ? 'DEMONTAGE' : 'REASSEMBLY', previousSlot)
              }

              pushEvent(
                `${phase === 'DEM' ? 'DEMONTAGE' : 'MONTAGE'}:${displayLabel}_START`,
                b.orderId,
                slotIdx
              )
              activesRef.current.push({
                orderId: b.orderId,
                label: displayLabel,
                slotIdx,
                remaining: nxt.duration,
                total: nxt.duration,
              })
              setActiveOrders(prev => prev.map(o => {
                if (o.id !== b.orderId) return o
                const sd = { ...(o.stationDurations || {}) }
                sd[mainId] = { expected: nxt.duration, actual: nxt.duration, startTime: new Date(), completed: false }
                return { ...o, currentStation: mainId, progress: 0, stationDurations: sd, isWaiting: false }
              }))
              orderPhaseSlotMapRef.current[phaseKey] = slotIdx
              if (mainStation) {
                mainStation.currentOrder = activeOrdersRef.current.find(o => o.id === b.orderId) as any
              }
            }
          }

          setPhaseQueueLen(mainId as any, queueRef.current.length)

          if (mainStation) {
            if (activesRef.current.length === 0) {
              mainStation.currentOrder = null
            } else {
              const activeOrderId = activesRef.current[0]?.orderId
              const activeOrder = activeOrdersRef.current.find(o => o.id === activeOrderId)
              mainStation.currentOrder = activeOrder ? (activeOrder as any) : null
            }
          }
        }

        const msg0 = `⏰ About to call tickPhase @t=${getSimMinutes()} demQueue=${demQueueRef.current.length}`
        console.log(msg0)
        dispatcherLogsRef.current.push(msg0)
        if (dispatcherLogsRef.current.length > 50) dispatcherLogsRef.current.shift()

        tickPhase('DEM')
        tickPhase('MON')

        // Update phase node live stats (deferred to avoid setState during render)
        setTimeout(() => {
          try {
            setNodes(prev => prev.map(n => {
              if (n.id === 'demontage-phase') {
                return {
                  ...n,
                  data: {
                    ...(n.data || {}),
                    queue: demQueueRef.current.length || 0,
                    totalSlots: demSlotsRef.current.length || 0,
                    busySlots: (demSlotsRef.current.filter(s => s.busy).length) || 0,
                    slots: demSlotsRef.current.map(s => ({ flex: s.flex, specialization: s.specialization || null, busy: s.busy }))
                  }
                } as any
              }
              if (n.id === 'reassembly-phase') {
                return {
                  ...n,
                  data: {
                    ...(n.data || {}),
                    queue: monQueueRef.current.length || 0,
                    totalSlots: monSlotsRef.current.length || 0,
                    busySlots: (monSlotsRef.current.filter(s => s.busy).length) || 0,
                    slots: monSlotsRef.current.map(s => ({ flex: s.flex, specialization: s.specialization || null, busy: s.busy }))
                  }
                } as any
              }
              return n
            }))
          } catch {}
        }, 0)

        // Track waiting times for orders in queue (aggregateView mode)
        activeOrdersRef.current.forEach(order => {
          if (order.isWaiting && !order.completedAt) {
            const stationId = order.currentStation
            if (!order.stationDurations[stationId]) {
              order.stationDurations[stationId] = {
                expected: 0,
                waitingTime: 0,
                startTime: new Date(),
                completed: false
              }
            }
            // Increment waiting time
            order.stationDurations[stationId].waitingTime =
              (order.stationDurations[stationId].waitingTime || 0) + deltaMinutes
          }
        })

        // Sync active orders list (drop completed)
        try {
          setActiveOrders(prev => prev.filter(o => !o.completedAt))
        } catch {}

        // Return without station-level assignment
        return updatedStations
      }
      
      // Phase utilization snapshot
      const getActivePhaseCount = (phasePrefix: 'demontage-' | 'reassembly-') =>
        updatedStations.filter(s => s.id.startsWith(phasePrefix) && s.currentOrder).length
      
      // First, assign unassigned orders to available stations
      activeOrders.forEach(order => {
        const currentStationData = updatedStations.find(s => s.id === order.currentStation);
        
        // Debug logging for demontage-waiting assignment
        if (order.currentStation === 'demontage-waiting' && currentStationData) {
          console.log(`Assigning ${order.kundeName} to demontage-waiting:`, {
            stationHasCurrentOrder: !!currentStationData.currentOrder,
            orderIsWaiting: order.isWaiting,
            willAssign: !currentStationData.currentOrder && !order.isWaiting
          });
        }
        
        // If order is at a station but not assigned to the station, assign it (unless station is busy)
        if (currentStationData && !currentStationData.currentOrder && !order.isWaiting) {
          const isDemSub = currentStationData.id.startsWith('demontage-')
          const isReaSub = currentStationData.id.startsWith('reassembly-')
          const demFull = isDemSub && getActivePhaseCount('demontage-') >= demSlots
          const monFull = isReaSub && getActivePhaseCount('reassembly-') >= monSlots
          if (demFull || monFull) {
            // Gate by phase capacity: keep in queue
            currentStationData.waitingQueue = currentStationData.waitingQueue || []
            if (!currentStationData.waitingQueue.find((o: any) => o.id === order.id)) {
              currentStationData.waitingQueue.push(order)
            }
            order.isWaiting = true
            console.log(`Capacity gating: queuing ${order.kundeName} at ${currentStationData.id}`)
          } else {
            currentStationData.currentOrder = order;
            console.log(`Assigned ${order.kundeName} to ${currentStationData.name}`);
          }
        }
      });
      
      // Process orders currently in stations
      activeOrders.forEach(order => {
        const currentStationData = updatedStations.find(s => s.id === order.currentStation);
        
        // Debug logging for demontage-waiting
        if (order.currentStation === 'demontage-waiting') {
          console.log(`Order ${order.kundeName} at demontage-waiting:`, {
            isAssignedToStation: currentStationData?.currentOrder?.id === order.id,
            progress: order.progress,
            isWaiting: order.isWaiting,
            nextStation: order.processSequence[order.processSequence.indexOf(order.currentStation) + 1]
          });
        }
        
        if (currentStationData && currentStationData.currentOrder?.id === order.id) {
          // Initialize station duration tracking if not already done
          if (!order.stationDurations[order.currentStation]) {
            const stochasticTime = calculateStochasticProcessingTime(
              currentStationData.processingTime, 
              currentStationData.stochasticVariation
            );
            order.stationDurations[order.currentStation] = {
              expected: currentStationData.processingTime,
              actual: stochasticTime,
              startTime: new Date(),
              completed: false
            };
            order.stationStartTime = new Date();
            order.progress = 0;
            order.isWaiting = false;
            // Log START for sub-ops
            if (order.currentStation.startsWith('demontage-')) {
              const lbl = currentStationData.name?.replace('Demontage ', '') || order.currentStation
              const key = `${order.id}:demontage-`
              const slotIdx = orderPhaseSlotMapRef.current[key]
              pushEvent(`DEMONTAGE:${lbl}_START`, order.id, slotIdx ?? null)
            } else if (order.currentStation.startsWith('reassembly-')) {
              const lbl = currentStationData.name?.replace('Montage ', '') || order.currentStation
              const key = `${order.id}:reassembly-`
              const slotIdx = orderPhaseSlotMapRef.current[key]
              pushEvent(`MONTAGE:${lbl}_START`, order.id, slotIdx ?? null)
            }
          }
          
          const prevProgress = order.progress;
          const requiredTime = order.stationDurations[order.currentStation].actual || currentStationData.processingTime;
          order.progress = Math.min(order.progress + deltaMinutes, requiredTime); // Cap progress at required time
          
          // Debug if we hit the cap
          if (prevProgress + deltaMinutes > requiredTime && order.progress === requiredTime) {
            console.log(`Progress capped for ${order.kundeName} at ${order.currentStation}: was going to be ${(prevProgress + deltaMinutes).toFixed(2)}, capped at ${requiredTime.toFixed(2)}`);
          }
          
          // Debug logging for demontage-waiting progress
          if (order.currentStation === 'demontage-waiting') {
            console.log(`${order.kundeName} demontage-waiting progress: ${order.progress.toFixed(2)}/${requiredTime.toFixed(2)}`);
          }
          
          if (order.progress >= requiredTime) {
            // Mark station duration as completed
            order.stationDurations[order.currentStation].completed = true;
            
            // Save station duration to database
            const stationDuration = order.stationDurations[order.currentStation];
            if (stationDuration.startTime) {
              saveStationDuration(
                order.id,
                order.currentStation,
                currentStationData.name,
                currentStationData.type,
                stationDuration.expected,
                stationDuration.actual || requiredTime,
                stationDuration.startTime,
                new Date()
              );
            }
            // Log END event for sub-ops
            if (order.currentStation.startsWith('demontage-')) {
              const lbl = currentStationData.name?.replace('Demontage ', '') || order.currentStation
              const key = `${order.id}:demontage-`
              const slotIdx = orderPhaseSlotMapRef.current[key]
              pushEvent(`DEMONTAGE:${lbl}_END`, order.id, slotIdx ?? null)
            } else if (order.currentStation.startsWith('reassembly-')) {
              const lbl = currentStationData.name?.replace('Montage ', '') || order.currentStation
              const key = `${order.id}:reassembly-`
              const slotIdx = orderPhaseSlotMapRef.current[key]
              pushEvent(`MONTAGE:${lbl}_END`, order.id, slotIdx ?? null)
            }
            
            // Free current station
            currentStationData.currentOrder = null;
            // Release slot if this was a demontage/reassembly sub-station
            if (order.currentStation.startsWith('demontage-')) {
              const key = `${order.id}:demontage-`
              const idx = orderPhaseSlotMapRef.current[key]
              if (idx !== undefined) {
                releaseSlot('DEMONTAGE', idx)
                delete orderPhaseSlotMapRef.current[key]
              }
            } else if (order.currentStation.startsWith('reassembly-')) {
              const key = `${order.id}:reassembly-`
              const idx = orderPhaseSlotMapRef.current[key]
              if (idx !== undefined) {
                releaseSlot('REASSEMBLY', idx)
                delete orderPhaseSlotMapRef.current[key]
              }
            }
            
            // Try to assign next order from waiting queue to current station using selected scheduling algorithm
            if (currentStationData.waitingQueue.length > 0) {
              const isDemSub = currentStationData.id.startsWith('demontage-')
              const isReaSub = currentStationData.id.startsWith('reassembly-')
              const demFull = isDemSub && getActivePhaseCount('demontage-') >= demSlots
              const monFull = isReaSub && getActivePhaseCount('reassembly-') >= monSlots
              if (!(demFull || monFull)) {
                const schedulingStrategy = schedulingStrategies[currentSchedulingAlgorithm as SchedulingAlgorithm];
                const nextOrder = schedulingStrategy.selectNext(currentStationData.waitingQueue, simulationTime);
                
                if (nextOrder) {
                  // Remove the selected order from the waiting queue
                  const orderIndex = currentStationData.waitingQueue.findIndex(o => o.id === nextOrder.id);
                  if (orderIndex >= 0) {
                    currentStationData.waitingQueue.splice(orderIndex, 1);
                    // Check slot availability for sub stations
                    const isDemSub2 = currentStationData.id.startsWith('demontage-')
                    const isReaSub2 = currentStationData.id.startsWith('reassembly-')
                    const opLabel2 = currentStationData.name?.replace('Demontage ', '')?.replace('Montage ', '') || currentStationData.id
                    let pickedSlot2 = -1
                    if (isDemSub2) pickedSlot2 = pickSlot('DEMONTAGE', opLabel2)
                    if (isReaSub2) pickedSlot2 = pickSlot('REASSEMBLY', opLabel2)
                    if (pickedSlot2 >= 0) {
                      currentStationData.currentOrder = nextOrder;
                      nextOrder.isWaiting = false;
                      const phaseKey2 = isDemSub2 ? 'demontage-' : 'reassembly-'
                      orderPhaseSlotMapRef.current[`${nextOrder.id}:${phaseKey2}`] = pickedSlot2
                      // Initialize stationDurations when order starts processing
                      if (!nextOrder.stationDurations[currentStationData.id] || !nextOrder.stationDurations[currentStationData.id].actual) {
                        const stochasticTime = calculateStochasticProcessingTime(
                          currentStationData.processingTime, 
                          currentStationData.stochasticVariation
                        );
                        nextOrder.stationDurations[currentStationData.id] = {
                          ...nextOrder.stationDurations[currentStationData.id], // Keep existing data like waitingTime
                          expected: currentStationData.processingTime,
                          actual: stochasticTime,
                          startTime: new Date(),
                          completed: false
                        };
                        nextOrder.progress = 0; // Reset progress for actual processing
                        console.log(`Fixed stationDurations for ${nextOrder.kundeName} at ${currentStationData.id}: actual=${stochasticTime}min`);
                      }
                    } else {
                      // Put back to queue front if no slot can switch now
                      currentStationData.waitingQueue.unshift(nextOrder)
                    }
                  }
              } else {
                console.log(`Capacity gating: not pulling from queue at ${currentStationData.id}`)
              }
            }
            }
            
            // Simplified logic: just follow the processSequence array in order
            const currentIndex = order.processSequence.indexOf(order.currentStation);
            console.log(`${order.kundeName} completed ${order.currentStation}, current index: ${currentIndex}, sequence length: ${order.processSequence.length}`);
            
            if (currentIndex < order.processSequence.length - 1) {
              const nextStationId = order.processSequence[currentIndex + 1];
              const nextStation = updatedStations.find(s => s.id === nextStationId);
              
              console.log(`${order.kundeName} moving from ${order.currentStation} to ${nextStationId}`);
              
              if (nextStation) {
                const phasePrefix: any = nextStationId.startsWith('demontage-') ? 'demontage-' : (nextStationId.startsWith('reassembly-') ? 'reassembly-' : null)
                const phaseFull = phasePrefix === 'demontage-' 
                  ? getActivePhaseCount('demontage-') >= demSlots 
                  : phasePrefix === 'reassembly-' 
                    ? getActivePhaseCount('reassembly-') >= monSlots 
                    : false

                // Determine op type label for slot selection
                const opLabel = nextStation?.name?.replace('Demontage ', '')?.replace('Montage ', '') || nextStationId
                // Try to pick a slot when assigning into demontage/reassembly sub-stations
                let pickedSlot = -1
                if (nextStationId.startsWith('demontage-')) {
                  pickedSlot = pickSlot('DEMONTAGE', opLabel)
                } else if (nextStationId.startsWith('reassembly-')) {
                  pickedSlot = pickSlot('REASSEMBLY', opLabel)
                }

                if (!phaseFull && nextStation.currentOrder === null && (pickedSlot >= 0 || (!nextStationId.startsWith('demontage-') && !nextStationId.startsWith('reassembly-')))) {
                  // Next station is free and phase capacity/slot available
                  nextStation.currentOrder = order;
                  order.currentStation = nextStationId;
                  order.progress = 0;
                  order.isWaiting = false;
                  if (pickedSlot >= 0) {
                    orderPhaseSlotMapRef.current[`${order.id}:${phasePrefix}`] = pickedSlot
                  }
                  console.log(`${order.kundeName} assigned directly to ${nextStationId}`);
                } else {
                  // Busy, phase full or no slot available: enqueue at target station
                  nextStation.waitingQueue = nextStation.waitingQueue || []
                  nextStation.waitingQueue.push(order);
                  order.currentStation = nextStationId;
                  order.progress = 0;
                  order.isWaiting = true;
                  if (!order.stationDurations[nextStationId]) {
                    order.stationDurations[nextStationId] = {
                      expected: nextStation.processingTime,
                      waitingTime: 0,
                      startTime: new Date(),
                      completed: false
                    };
                  }
                  waitingOrdersList.push(order);
                  const reason = phaseFull ? 'phase capacity' : 'busy/slot'
                  console.log(`${order.kundeName} added to waiting queue of ${nextStationId} (${reason})`);
                }
                updatedOrders.push(order); // Make sure order stays in active list
              } else {
                console.error(`Next station ${nextStationId} not found for ${order.kundeName}`);
                updatedOrders.push(order); // Keep order in list even if error
              }
            } else {
              // Order completed
              console.log(`${order.kundeName} completed entire sequence!`);
              order.completedAt = new Date();
              order.schedulingAlgorithm = currentSchedulingAlgorithm;
              newCompletedOrders.push(order);
              // Add to shared context for KPI Dashboard
              addCompletedOrder(order);
            }
          } else {
            // Order still processing
            updatedOrders.push(order);
          }
        } else if (order.isWaiting) {
          // Order is waiting in queue - track waiting time
          if (order.stationDurations[order.currentStation]) {
            order.stationDurations[order.currentStation].waitingTime = 
              (order.stationDurations[order.currentStation].waitingTime || 0) + deltaMinutes;
          }
          waitingOrdersList.push(order);
        } else {
          // Order not yet assigned to station
          updatedOrders.push(order);
        }
      });
      
      // Update global state - completed orders are now handled by addCompletedOrder in the context
      if (newCompletedOrders.length > 0) {
        console.log(`Completed orders:`, newCompletedOrders.map(o => o.kundeName));
      }
      setWaitingOrders(waitingOrdersList);
      
      // Debug: log order counts
      console.log(`Order counts - Updated: ${updatedOrders.length}, Waiting: ${waitingOrdersList.length}, Completed: ${newCompletedOrders.length}`);
      console.log(`Active orders:`, updatedOrders.map(o => `${o.kundeName}@${o.currentStation}`));
      
      // Update orders list (remove completed orders and avoid duplicates)
      const allActiveOrders = [...updatedOrders];
      // Only add waiting orders that aren't already in updatedOrders
      waitingOrdersList.forEach(waitingOrder => {
        if (!allActiveOrders.find(order => order.id === waitingOrder.id)) {
          allActiveOrders.push(waitingOrder);
        }
      });
      setActiveOrders(allActiveOrders);
      
      return updatedStations;
    });
    
    // Update local stations to match context for flow diagram
    setLocalStations(stations);
    
    // Update the flow diagram to reflect current station status
    updateFlowDiagram();
  };

  const updateStationOrders = () => {
    // This function is now integrated into processOrders for better performance
    updateFlowDiagram();
  };

  // Prepare data for stacked bar chart
  const prepareChartData = () => {
    return completedOrders.map((order: any, index) => {
      const processingTime = Object.values(order.stationDurations || {})
        .filter((d: any) => d.completed)
        .reduce((sum: number, d: any) => sum + (d.actual || 0), 0);
      const waitingTime = Object.values(order.stationDurations || {})
        .filter((d: any) => d.completed)
        .reduce((sum: number, d: any) => sum + (d.waitingTime || 0), 0);

      return {
        name: `${order.kundeName || `${order.customer?.firstName} ${order.customer?.lastName}`}`,
        orderNumber: index + 1,
        Bearbeitungszeit: parseFloat(processingTime.toFixed(1)),
        Wartezeit: parseFloat(waitingTime.toFixed(1))
      };
    });
  };

  // Prepare station utilization data
  const prepareStationUtilizationData = () => {
    try {
      // Return aggregate data for Demontage and Montage phases based on Gantt events
      if (!simulationStartTime) {
        return [
          { name: `Demontage (${demSlotsRef.current.length} Slots)`, station: 'Demontage', utilizationRate: 0, processingTime: 0, totalTime: 0 },
          { name: `Montage (${monSlotsRef.current.length} Slots)`, station: 'Montage', utilizationRate: 0, processingTime: 0, totalTime: 0 }
        ];
      }

      const simDurationMinutes = getSimMinutes()
      if (simDurationMinutes <= 0) {
        return [
          { name: `Demontage (${demSlotsRef.current.length} Slots)`, station: 'Demontage', utilizationRate: 0, processingTime: 0, totalTime: 0 },
          { name: `Montage (${monSlotsRef.current.length} Slots)`, station: 'Montage', utilizationRate: 0, processingTime: 0, totalTime: 0 }
        ];
      }

      // Calculate from Gantt events
      const events = [...simEventsRef.current]
      const starts: Record<string, { t:number; activity:string; order_id:string }> = {}
      const segments: Array<{ order_id:string; phase:string; start:number; end:number; duration:number }>=[]

      for (const ev of events) {
        const act = ev.activity
        if (typeof act !== 'string') continue
        if (act.endsWith('_START')) {
          const stem = act.slice(0, -6)
          const phase = act.startsWith('DEMONTAGE:') ? 'DEMONTAGE' : act.startsWith('MONTAGE:') ? 'MONTAGE' : null
          if (phase) {
            starts[`${ev.order_id}|${stem}`] = { t: ev.t, activity: stem, order_id: ev.order_id }
          }
        } else if (act.endsWith('_END')) {
          const stem = ev.activity.slice(0, -4)
          const s = starts[`${ev.order_id}|${stem}`]
          if (s) {
            const phase = ev.activity.startsWith('DEMONTAGE:') ? 'DEMONTAGE' : ev.activity.startsWith('MONTAGE:') ? 'MONTAGE' : null
            if (phase) {
              segments.push({
                order_id: ev.order_id,
                phase,
                start: s.t,
                end: ev.t,
                duration: Math.max(0, ev.t - s.t)
              })
            }
            delete starts[`${ev.order_id}|${stem}`]
          }
        }
      }

      const demSegments = segments.filter(s => s.phase === 'DEMONTAGE')
      const monSegments = segments.filter(s => s.phase === 'MONTAGE')

      const demTotalBusyTime = demSegments.reduce((sum, seg) => sum + seg.duration, 0)
      const monTotalBusyTime = monSegments.reduce((sum, seg) => sum + seg.duration, 0)

      const demSlotCount = demSlotsRef.current.length || 1
      const monSlotCount = monSlotsRef.current.length || 1

      const demUtilization = (demTotalBusyTime / (simDurationMinutes * demSlotCount)) * 100
      const monUtilization = (monTotalBusyTime / (simDurationMinutes * monSlotCount)) * 100

      return [
        {
          name: `Demontage (${demSlotCount} Slots)`,
          station: 'Demontage',
          utilizationRate: parseFloat(demUtilization.toFixed(1)),
          processingTime: parseFloat(demTotalBusyTime.toFixed(1)),
          totalTime: parseFloat(simDurationMinutes.toFixed(1))
        },
        {
          name: `Montage (${monSlotCount} Slots)`,
          station: 'Montage',
          utilizationRate: parseFloat(monUtilization.toFixed(1)),
          processingTime: parseFloat(monTotalBusyTime.toFixed(1)),
          totalTime: parseFloat(simDurationMinutes.toFixed(1))
        }
      ];
    } catch (error) {
      console.error('Error in prepareStationUtilizationData:', error);
      return [
        { name: 'Demontage', station: 'Demontage', utilizationRate: 0, processingTime: 0, totalTime: 0 },
        { name: 'Montage', station: 'Montage', utilizationRate: 0, processingTime: 0, totalTime: 0 }
      ];
    }
  };

      
      // If no SUB stations with parent, try with different criteria
      if (demontageStations.length === 0 && reassemblyStations.length === 0) {
        // Try finding stations by ID pattern
        const demontageByPattern = stations.filter(s => s?.id?.includes('demontage-')).slice(0, 6);
        const reassemblyByPattern = stations.filter(s => s?.id?.includes('reassembly-')).slice(0, 6);
        
        console.log('Trying pattern match:', {
          demontageByPattern: demontageByPattern.map(s => ({ id: s.id, name: s.name })),
          reassemblyByPattern: reassemblyByPattern.map(s => ({ id: s.id, name: s.name }))
        });
        
        if (demontageByPattern.length > 0 || reassemblyByPattern.length > 0) {
          const allStations = [...demontageByPattern, ...reassemblyByPattern];
          return allStations.map(station => ({
            name: `${station.id?.includes('demontage') ? 'Disassembly' : 'Assembly'}: ${station.name || 'Unknown'}`,
            station: station.name || 'Unknown',
            utilizationRate: 0,
            processingTime: 0,
            totalTime: 0
          }));
        }
      }
      
      const allSubStations = [...demontageStations, ...reassemblyStations];
      
      console.log('Final station selection:', {
        demontage: demontageStations.length,
        reassembly: reassemblyStations.length,
        total: allSubStations.length,
        demontageStations: demontageStations.map(s => ({ id: s.id, name: s.name, parent: s.parent })),
        reassemblyStations: reassemblyStations.map(s => ({ id: s.id, name: s.name, parent: s.parent }))
      });
      
      // If we still have no stations, return empty array
      if (allSubStations.length === 0) {
        console.log('No SUB stations found with proper filtering');
        return [];
      }
      
      // Ensure we have valid simulation times
      if (!simulationTime || !simulationStartTime) {
        console.log('No simulation times, returning stations with 0% utilization');
        return allSubStations.map((station) => {
          const stationType = station.parent === 'demontage' ? 'Disassembly' : 'Assembly';
          const stationName = station.name || 'Unknown';
          return {
            name: `${stationType}: ${stationName}`,
            station: stationName,
            utilizationRate: 0,
            processingTime: 0,
            totalTime: 0
          };
        });
      }
      
      // Return empty data if simulation hasn't started
      if (!simulationStartTime) {
        return allSubStations.map(station => ({
          name: `${station.parent === 'demontage' ? 'Disassembly' : 'Assembly'}: ${station.name || 'Unknown'}`,
          station: station.name || 'Unknown',
          utilizationRate: 0,
          processingTime: 0,
          totalTime: 0
        }));
      }
      
      const currentTime = simulationTime.getTime();
      const simulationDurationMs = currentTime - simulationStartTime.getTime();
      const simulationDurationMinutes = Math.max(simulationDurationMs / (1000 * 60), 0.01); // Minimum 0.01 minutes
      
      console.log('BAR CHART - Simulation timing:', {
        currentTime: new Date(currentTime).toISOString(),
        startTime: new Date(simulationStartTime.getTime()).toISOString(),
        durationMs: simulationDurationMs,
        durationMinutes: simulationDurationMinutes.toFixed(2),
        completedOrders: completedOrders.length,
        activeOrders: activeOrders.length
      });
      
      return allSubStations.map(station => {
        if (!station?.id) {
          return {
            name: 'Unknown Station',
            station: 'Unknown',
            utilizationRate: 0,
            processingTime: 0,
            totalTime: parseFloat(simulationDurationMinutes.toFixed(1))
          };
        }
        
        // Calculate total processing time for this station from all completed orders
        const completedOrdersDebug: any[] = [];
        const totalProcessingTime = (completedOrders || []).reduce((sum: number, order: any) => {
          const stationDuration = order?.stationDurations?.[station.id];
          const actualTime = stationDuration?.actual || 0;
          if (actualTime > 0) {
            completedOrdersDebug.push({ orderId: order.id, actualTime });
          }
          return sum + actualTime;
        }, 0);
        
        // Also include time from currently active orders at this station
        const activeOrdersDebug: any[] = [];
        const activeProcessingTime = (activeOrders || []).reduce((sum: number, order: any) => {
          if (order.currentStation === station.id && !order.isWaiting) {
            const progress = order.progress || 0;
            if (progress > 0) {
              activeOrdersDebug.push({ orderId: order.id, progress });
            }
            return sum + progress;
          }
          return sum;
        }, 0);
        
        const totalStationTime = totalProcessingTime + activeProcessingTime;
        
        // Calculate utilization percentage - capped at 100%
        const utilizationRate = simulationDurationMinutes > 0 
          ? Math.min((totalStationTime / simulationDurationMinutes) * 100, 100)
          : 0;
          
        // Debug impossible utilization
        if (utilizationRate > 100) {
          console.error(`🚨 BAR CHART IMPOSSIBLE UTILIZATION: Station ${station.id}:`, {
            totalStationTime: totalStationTime.toFixed(1) + 'min',
            simulationDuration: simulationDurationMinutes.toFixed(1) + 'min',
            completedOrdersTime: totalProcessingTime.toFixed(1) + 'min',
            activeOrdersTime: activeProcessingTime.toFixed(1) + 'min',
            completedOrdersDetail: completedOrdersDebug,
            activeOrdersDetail: activeOrdersDebug,
            ratio: utilizationRate.toFixed(1) + '%'
          });
        }
        
        // Debug high utilization for tracking
        if (utilizationRate > 50) {
          console.log(`BAR CHART Station ${station.id} high utilization:`, {
            utilizationRate: utilizationRate.toFixed(1) + '%',
            totalTime: totalStationTime.toFixed(1) + 'min',
            simulationDuration: simulationDurationMinutes.toFixed(1) + 'min'
          });
        }
        
        // Determine station type and use the actual station name (Baugruppentyp name)
        const stationType = station.parent === 'demontage' ? 'Disassembly' : 'Assembly';
        const stationName = station.name || 'Unknown';
        
        const result = {
          name: `${stationType}: ${stationName}`,
          station: stationName,
          utilizationRate: parseFloat(utilizationRate.toFixed(1)) || 0,
          processingTime: parseFloat(totalStationTime.toFixed(1)) || 0,
          totalTime: parseFloat(simulationDurationMinutes.toFixed(1)) || 0
        };
        
        // Always log station info for debugging
        console.log(`Station ${station.id}:`, result);
        
        return result;
      });
    } catch (error) {
      console.error('Error in prepareStationUtilizationData:', error);
      return [];
    }
  };

  const updateFlowDiagram = () => {
    setNodes(prevNodes => 
      prevNodes.map(node => {
        const station = stations.find(s => s.id === node.id);
        if (station) {
          const isParent = station.id === 'demontage' || station.id === 'reassembly';
          const isDemontage = station.id === 'demontage';
          const isReassembly = station.id === 'reassembly';
          const isSub = station.type === 'SUB';
          
          let title = station.name;
          if (isDemontage) {
            const demontageCount = stations.filter(s => s.type === 'SUB' && s.parent === 'demontage').length;
            title = `${station.name} (${demontageCount} Baugruppentypen)`;
          } else if (isReassembly) {
            const reassemblyCount = stations.filter(s => s.type === 'SUB' && s.parent === 'reassembly').length;
            title = `${station.name} (${reassemblyCount} Baugruppentypen)`;
          }
          
          if (isSub) {
            // Handle sub-station updates with new structure
            const currentOrderName = station.currentOrder?.kundeName || 'Frei';
            const waitingCount = station.waitingQueue?.length || 0;
            const isOccupied = station.currentOrder !== null;
            
            return {
              ...node,
              data: {
                label: (
                  <div className="text-center">
                    <div className="text-xs font-bold text-gray-800">
                      {station.name.replace('Demontage ', '').replace('Montage ', '')}
                    </div>
                    <div className={`text-xs font-medium px-1 py-0.5 rounded mt-1 ${
                      isOccupied 
                        ? 'bg-red-100 text-red-800' 
                        : 'bg-green-100 text-green-800'
                    }`}>
                      {isOccupied ? currentOrderName : 'Frei'}
                    </div>
                    <div className="text-xs text-gray-600 mt-0.5">
                      {station.processingTime}min (±{Math.round(station.stochasticVariation * 100)}%)
                    </div>
                    {waitingCount > 0 && (
                      <div className="text-xs bg-orange-100 text-orange-800 px-1 rounded mt-0.5">
                        Warteschlange: {waitingCount}
                      </div>
                    )}
                  </div>
                )
              },
              style: {
                ...node.style,
                background: isOccupied ? '#fef2f2' : (station.parent === 'demontage' ? '#f0f9ff' : '#f0fdf4'),
                border: `2px solid ${isOccupied ? '#dc2626' : (station.parent === 'demontage' ? '#3b82f6' : '#16a34a')}`,
                height: 70
              }
            };
          } else {
            // Handle main station updates
            const currentOrderName = station.currentOrder?.kundeName || '';
            const waitingCount = station.waitingQueue?.length || 0;
            const isOccupied = station.currentOrder !== null;
            
            return {
              ...node,
              data: {
                label: (
                  <div className="text-center">
                    <div className="font-bold">{title}</div>
                    {!isParent && (
                      <>
                        <div className="text-xs text-gray-500">
                          {station.processingTime} min (±{Math.round(station.stochasticVariation * 100)}%)
                        </div>
                        {isOccupied && (
                          <div className="text-xs bg-blue-100 text-blue-800 px-1 rounded mt-1">
                            {currentOrderName}
                          </div>
                        )}
                      </>
                    )}
                  </div>
                )
              }
            };
          }
        }
        return node;
      })
    );
  };

  const handleStationClick = (stationId: string) => {
    const station = stations.find(s => s.id === stationId);
    if (station) {
      if (station.id === 'inspection') {
        // Open inspection-specific dialog
        setInspectionDialogOpen(true);
      } else {
        // Open general station configuration dialog
        setSelectedStation(station);
        setTempProcessingTime(station.processingTime);
        setStationDialogOpen(true);
      }
    }
  };

  const handleSaveStationTime = () => {
    if (selectedStation) {
      setContextStations(prev => 
        prev.map(s => 
          s.id === selectedStation.id 
            ? { ...s, processingTime: tempProcessingTime }
            : s
        )
      );
      setLocalStations(prev => 
        prev.map(s => 
          s.id === selectedStation.id 
            ? { ...s, processingTime: tempProcessingTime }
            : s
        )
      );
      toast.success(`Bearbeitungszeit für ${selectedStation.name} aktualisiert`);
      setStationDialogOpen(false);
    }
  };

  const handleSpeedChange = (value: number[]) => {
    setSpeed(value[0]);
  };

  const handleCreateNewOrder = async () => {
    if (!activeFactory) return;
    
    try {
      // Use the exact same logic as Auftragsübersicht by calling generateOrders
      const response = await fetch('/api/auftrag', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          action: 'generateOrders',
          factoryId: activeFactory.id,
          count: 1 // Create just one order
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // Reload simulation data to get the new order
        await loadSimulationData();
        toast.success('Neuer Auftrag erfolgreich erstellt');
      } else {
        toast.error(result.error || 'Fehler beim Erstellen des Auftrags');
      }
    } catch (error) {
      console.error('Error creating new order:', error);
      toast.error('Fehler beim Erstellen des neuen Auftrags');
    }
  };

  const handleClearAllOrders = async () => {
    if (!activeFactory) return;
    
    try {
      // Stop the simulation first
      setIsRunning(false);
      
      // Delete orders from database
      const response = await fetch('/api/auftrag', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          action: 'deleteAllOrders',
          factoryId: activeFactory.id
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // Clear all orders from simulation - handled by context clearAllData
        
        // Clear all stations - reset their current orders and waiting queues
        setContextStations(prevStations => {
          const clearedStations = prevStations.map(station => ({
            ...station,
            currentOrder: null,
            waitingQueue: []
          }));
          setLocalStations(clearedStations);
          return clearedStations;
        });
        
        // Clear active orders and waiting orders in context
        setActiveOrders([]);
        setWaitingOrders([]);
        
        // Reset simulation time
        setSimulationTime(new Date());
        setSimulationStartTime(new Date());
        
        // Force refresh of the entire app to update Auftragsübersicht
        router.refresh();
        
        toast.success(`Alle Aufträge gelöscht (${result.deletedCount} aus Datenbank)`);
      } else {
        toast.error(result.error || 'Fehler beim Löschen der Aufträge');
      }
    } catch (error) {
      console.error('Error deleting orders:', error);
      toast.error('Fehler beim Löschen der Aufträge');
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-96">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Lade Simulationsdaten...</p>
        </div>
      </div>
    );
  }

  // Data Dashboard view
  if (currentView === 'kpi') {
    return (
      <div className="space-y-4">
        {/* Go back button */}
        <div className="flex items-center gap-2">
          <Button
            onClick={() => setCurrentView('simulation')}
            variant="outline"
            size="sm"
          >
            <ArrowLeft className="h-4 w-4 mr-1" />
            Zurück zur Simulation
          </Button>
        </div>
        
        {/* Data Dashboard */}
        {(() => {
          // Calculate KPIs from Gantt Chart events
          const events = [...simEventsRef.current]
          const starts: Record<string, { t:number; activity:string; order_id:string }> = {}
          const segments: Array<{ order_id:string; start:number; end:number; duration:number }>=[]

          // Parse all events to get processing segments
          for (const ev of events) {
            const act = ev.activity
            if (typeof act !== 'string') continue
            if (act.endsWith('_START')) {
              const stem = act.slice(0, -6)
              starts[`${ev.order_id}|${stem}`] = { t: ev.t, activity: stem, order_id: ev.order_id }
            } else if (act.endsWith('_END')) {
              const stem = ev.activity.slice(0, -4)
              const s = starts[`${ev.order_id}|${stem}`]
              if (s) {
                segments.push({
                  order_id: ev.order_id,
                  start: s.t,
                  end: ev.t,
                  duration: Math.max(0, ev.t - s.t)
                })
                delete starts[`${ev.order_id}|${stem}`]
              }
            }
          }

          // Calculate total processing time from segments
          const totalProcessingTimeMinutes = segments.reduce((sum, seg) => sum + seg.duration, 0)

          // Calculate total lead time for completed orders (from first event to completion)
          const orderTimes: Record<string, { firstStart: number; lastEnd: number }> = {}
          segments.forEach(seg => {
            if (!orderTimes[seg.order_id]) {
              orderTimes[seg.order_id] = { firstStart: seg.start, lastEnd: seg.end }
            } else {
              orderTimes[seg.order_id].firstStart = Math.min(orderTimes[seg.order_id].firstStart, seg.start)
              orderTimes[seg.order_id].lastEnd = Math.max(orderTimes[seg.order_id].lastEnd, seg.end)
            }
          })

          // Calculate waiting time = lead time - processing time for each order
          const completedOrderIds = completedOrders.map(o => o.id)
          let totalWaitingTimeMinutes = 0
          let totalLeadTimeMinutes = 0

          completedOrderIds.forEach(orderId => {
            const times = orderTimes[orderId]
            if (times) {
              const leadTime = times.lastEnd - times.firstStart
              const processingTime = segments.filter(s => s.order_id === orderId).reduce((sum, s) => sum + s.duration, 0)
              const waitingTime = leadTime - processingTime
              totalLeadTimeMinutes += leadTime
              totalWaitingTimeMinutes += waitingTime
            }
          })

          const avgProcessingTime = completedOrders.length > 0 ? totalProcessingTimeMinutes / completedOrders.length : 0
          const avgWaitingTime = completedOrders.length > 0 ? totalWaitingTimeMinutes / completedOrders.length : 0
          const avgLeadTime = completedOrders.length > 0 ? totalLeadTimeMinutes / completedOrders.length : 0

          // Calculate utilization for Demontage and Montage phases
          const simDurationMinutes = getSimMinutes()
          const demSlotCount = demSlotsRef.current.length || 1
          const monSlotCount = monSlotsRef.current.length || 1

          // Get segments for each phase
          const demSegments = segments.filter(s => {
            const ev = events.find(e => e.order_id === s.order_id && e.t === s.start)
            return ev && typeof ev.activity === 'string' && ev.activity.startsWith('DEMONTAGE:')
          })
          const monSegments = segments.filter(s => {
            const ev = events.find(e => e.order_id === s.order_id && e.t === s.start)
            return ev && typeof ev.activity === 'string' && ev.activity.startsWith('MONTAGE:')
          })

          const demTotalBusyTime = demSegments.reduce((sum, seg) => sum + seg.duration, 0)
          const monTotalBusyTime = monSegments.reduce((sum, seg) => sum + seg.duration, 0)

          const demUtilization = simDurationMinutes > 0 && demSlotCount > 0
            ? (demTotalBusyTime / (simDurationMinutes * demSlotCount)) * 100
            : 0
          const monUtilization = simDurationMinutes > 0 && monSlotCount > 0
            ? (monTotalBusyTime / (simDurationMinutes * monSlotCount)) * 100
            : 0

          // Create enriched orders with calculated metrics
          const enrichedCompletedOrders = completedOrders.map(order => {
            const times = orderTimes[order.id]
            if (times) {
              const leadTime = times.lastEnd - times.firstStart
              const processingTime = segments.filter(s => s.order_id === order.id).reduce((sum, s) => sum + s.duration, 0)
              const waitingTime = leadTime - processingTime
              return {
                ...order,
                calculatedMetrics: {
                  leadTime,
                  processingTime,
                  waitingTime
                }
              }
            }
            return order
          })

          return (
            <AdvancedKPIDashboard
              orders={activeOrders}
              completedOrders={enrichedCompletedOrders as any}
              stations={stations}
              onClearData={handleClearAllOrders}
              calculatedKPIs={{
                avgProcessingTime,
                avgWaitingTime,
                avgLeadTime,
                demUtilization,
                monUtilization,
                totalProcessingTime: totalProcessingTimeMinutes,
                totalWaitingTime: totalWaitingTimeMinutes,
                totalLeadTime: totalLeadTimeMinutes
              }}
            />
          )
        })()}

        {/* Simple Gantt (beta): recent segments */}
        {/* Gantt Tabelle (letzte Segmente) */}
        <Card>
          <CardHeader>
            <CardTitle>Gantt Tabelle – letzte Segmente</CardTitle>
          </CardHeader>
          <CardContent key={`gtab-${ganttRefreshKey}`}>
            {(() => {
              try {
                const events = [...simEventsRef.current]
                const starts: Record<string, { t:number; activity:string; slot?:number|null; order_id:string }> = {}
                const segments: Array<{ order_id:string; phase:string; sub_op:string; slot?:number|null; start:number; end:number; duration:number }>=[]
                for (const ev of events) {
                  const act = ev.activity
                  if (typeof act !== 'string') continue
                  if (act.endsWith('_START')) {
                    const stem = act.slice(0, -6)
                    starts[`${ev.order_id}|${stem}|${ev.slot ?? 'noslot'}`] = { t: ev.t, activity: stem, slot: ev.slot ?? null, order_id: ev.order_id }
                  } else if (act.endsWith('_END')) {
                    const stem = ev.activity.slice(0, -4)
                    const key = `${ev.order_id}|${stem}|${ev.slot ?? 'noslot'}`
                    const s = starts[key]
                    if (s) {
                      const parts = stem.split(':')
                      const phase = parts[0] || 'PHASE'
                      const sub = parts[1] || phase
                      segments.push({ order_id: ev.order_id, phase, sub_op: sub, slot: ev.slot ?? null, start: s.t, end: ev.t, duration: Math.max(0, ev.t - s.t) })
                      delete starts[key]
                    }
                  }
                }
                segments.sort((a,b)=> a.order_id.localeCompare(b.order_id) || a.start - b.start)
                const recent = segments.slice(-30).reverse()
                if (recent.length === 0) return <div className="text-sm text-muted-foreground">Noch keine Segmente erfasst.</div>
                return (
                  <div className="overflow-auto">
                    <table className="w-full text-sm">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Order</th>
                          <th className="py-1 pr-2">Phase</th>
                          <th className="py-1 pr-2">Sub‑Op</th>
                          <th className="py-1 pr-2">Slot</th>
                          <th className="py-1 pr-2">Start</th>
                          <th className="py-1 pr-2">Ende</th>
                          <th className="py-1 pr-2">Dauer</th>
                        </tr>
                      </thead>
                      <tbody>
                        {recent.map((seg, i) => (
                          <tr key={i} className="border-t">
                            <td className="py-1 pr-2 font-mono">{seg.order_id.slice(0,8)}</td>
                            <td className="py-1 pr-2">{seg.phase}</td>
                            <td className="py-1 pr-2">{seg.sub_op}</td>
                            <td className="py-1 pr-2">{seg.slot ?? '-'}</td>
                            <td className="py-1 pr-2">{seg.start}m</td>
                            <td className="py-1 pr-2">{seg.end}m</td>
                            <td className="py-1 pr-2">{seg.duration}m</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )
              } catch (e) {
                console.error('Gantt table render error', e)
                return <div className="text-sm text-red-500">Fehler beim Rendern der Gantt‑Tabelle.</div>
              }
            })()}
          </CardContent>
        </Card>

        {/* Gantt Plot */}
        <Card>
          <CardHeader>
            <CardTitle>Gantt – Unter‑Operationen</CardTitle>
          </CardHeader>
          <CardContent key={`gplot-${ganttRefreshKey}`}>
            {(() => {
              try {
                const events = [...simEventsRef.current]
                const starts: Record<string, { t:number; activity:string; slot?:number|null; order_id:string }> = {}
                const segs: Array<{ order_id:string; phase:string; sub_op:string; slot?:number|null; start:number; end:number; duration:number }>=[]
                for (const ev of events) {
                  const act = ev.activity
                  if (typeof act !== 'string') continue
                  if (act.endsWith('_START')) {
                    const stem = act.slice(0, -6)
                    starts[`${ev.order_id}|${stem}|${ev.slot ?? 'noslot'}`] = { t: ev.t, activity: stem, slot: ev.slot ?? null, order_id: ev.order_id }
                  } else if (act.endsWith('_END')) {
                    const stem = ev.activity.slice(0, -4)
                    const key = `${ev.order_id}|${stem}|${ev.slot ?? 'noslot'}`
                    const s = starts[key]
                    if (s) {
                      const parts = stem.split(':')
                      const phase = parts[0] || 'PHASE'
                      const sub = parts[1] || phase
                      segs.push({ order_id: ev.order_id, phase, sub_op: sub, slot: ev.slot ?? null, start: s.t, end: ev.t, duration: Math.max(0, ev.t - s.t) })
                      delete starts[key]
                    }
                  }
                }
                if (segs.length === 0) return <div className="text-sm text-muted-foreground">Noch keine Segmente erfasst.</div>
                const maxEnd = Math.max(...segs.map(s => s.end)) || 1
                const grouped: Record<string, typeof segs> = {}
                segs.forEach(s => { (grouped[s.order_id] ||= []).push(s) })
                Object.values(grouped).forEach(arr => arr.sort((a,b)=> a.start - b.start))
                const colorFor = (p: string) => p.startsWith('DEMONTAGE') ? '#2563eb' : p.startsWith('MONTAGE') ? '#16a34a' : '#6b7280'

                // Helper: Get customer name from order_id
                const getCustomerName = (orderId: string) => {
                  const order = activeOrders.find(o => o.id === orderId) || completedOrders.find(o => o.id === orderId)
                  if (order?.kundeName) {
                    // Shorten name: "Michael Williams" -> "Michael W."
                    const parts = order.kundeName.split(' ')
                    if (parts.length >= 2) return `${parts[0]} ${parts[1].charAt(0)}.`
                    return order.kundeName
                  }
                  return orderId.slice(0,8)
                }

                return (
                  <div className="space-y-3">
                    {Object.entries(grouped).map(([oid, arr], idx) => {
                      // Collect unique sub-operations for this order
                      const subOps = [...new Set(arr.map(s => s.sub_op))].join(', ')
                      return (
                        <div key={oid} className="relative border rounded p-2 bg-white">
                          <div className="absolute -left-1 -top-2 text-[10px] font-mono bg-gray-100 px-1 rounded border">
                            #{idx+1} {getCustomerName(oid)}
                          </div>
                          <div className="text-[9px] text-gray-600 mb-1 pl-1">{subOps}</div>
                          <div className="relative h-8 w-full">
                            {arr.map((s,i) => {
                              const barId = `${oid}-${i}`
                              const isBarHovered = hoveredOrderRow === barId
                              return (
                                <div
                                  key={i}
                                  className="absolute rounded transition-all cursor-pointer"
                                  style={{
                                    left: `${(s.start/maxEnd)*100}%`,
                                    width: `${(s.duration/maxEnd)*100}%`,
                                    top: isBarHovered ? 2 : 8,
                                    height: isBarHovered ? '24px' : '12px',
                                    background: colorFor(s.phase),
                                    zIndex: isBarHovered ? 50 : 1,
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                  }}
                                  onMouseEnter={() => setHoveredOrderRow(barId)}
                                  onMouseLeave={() => setHoveredOrderRow(null)}
                                  title={`${s.phase}:${s.sub_op}\nStart: ${s.start.toFixed(1)}m\nDauer: ${s.duration.toFixed(1)}m\nEnde: ${s.end.toFixed(1)}m`}
                                >
                                  {isBarHovered && (
                                    <span className="text-[9px] text-black font-semibold px-1 bg-white/90 rounded truncate whitespace-nowrap">
                                      {s.sub_op}
                                    </span>
                                  )}
                                </div>
                              )
                            })}
                          </div>
                        </div>
                      )
                    })}
                  </div>
                )
              } catch (e) {
                console.error('Gantt render error', e)
                return <div className="text-sm text-red-500">Fehler beim Rendern des Gantt.</div>
              }
            })()}
          </CardContent>
        </Card>

        {/* Demontage Slot Capacity Gantt */}
        <Card>
          <CardHeader>
            <CardTitle>Demontage Slot Capacity</CardTitle>
          </CardHeader>
          <CardContent key={`dem-slot-gantt-${ganttRefreshKey}`}>
            {(() => {
              try {
                const events = [...simEventsRef.current]
                const starts: Record<string, { t:number; activity:string; order_id:string }> = {}
                const segs: Array<{ slot:number; sub_op:string; order_id:string; start:number; end:number; duration:number }>=[]

                // Filter for DEMONTAGE events with slots
                for (const ev of events) {
                  const act = ev.activity
                  if (typeof act !== 'string' || !act.startsWith('DEMONTAGE:') || ev.slot == null) continue

                  if (act.endsWith('_START')) {
                    const stem = act.slice(0, -6)
                    const key = `${ev.order_id}|${stem}|${ev.slot}`
                    starts[key] = { t: ev.t, activity: stem, order_id: ev.order_id }
                  } else if (act.endsWith('_END')) {
                    const stem = ev.activity.slice(0, -4)
                    const key = `${ev.order_id}|${stem}|${ev.slot}`
                    const s = starts[key]
                    if (s && ev.slot != null) {
                      const sub = stem.split(':')[1] || stem
                      segs.push({ slot: ev.slot, sub_op: sub, order_id: ev.order_id, start: s.t, end: ev.t, duration: Math.max(0, ev.t - s.t) })
                      delete starts[key]
                    }
                  }
                }

                if (segs.length === 0) return <div className="text-sm text-muted-foreground">Noch keine Demontage-Slot-Operationen erfasst.</div>

                const maxEnd = Math.max(...segs.map(s => s.end)) || 1
                const slotGroups: Record<number, typeof segs> = {}
                segs.forEach(s => { (slotGroups[s.slot] ||= []).push(s) })
                Object.values(slotGroups).forEach(arr => arr.sort((a,b)=> a.start - b.start))

                // Helper: Get shortened customer name
                const getShortCustomerName = (orderId: string) => {
                  const order = activeOrders.find(o => o.id === orderId) || completedOrders.find(o => o.id === orderId)
                  if (order?.kundeName) {
                    const parts = order.kundeName.split(' ')
                    if (parts.length >= 2) return `${parts[0].charAt(0)}.${parts[1].charAt(0)}.`
                    return order.kundeName.substring(0, 4)
                  }
                  return orderId.slice(-4)
                }

                const slotIndices = Object.keys(slotGroups).map(Number).sort((a,b)=>a-b)

                return (
                  <div className="space-y-2">
                    {slotIndices.map(slotIdx => {
                      const arr = slotGroups[slotIdx]
                      return (
                        <div key={slotIdx} className="relative border rounded p-2 bg-white">
                          <div className="absolute -left-1 -top-2 text-[10px] font-mono bg-blue-100 px-1 rounded border text-blue-700">
                            Slot {slotIdx}
                          </div>
                          <div className="relative h-10 w-full">
                            {arr.map((s,i) => {
                              const barId = `dem-${slotIdx}-${i}`
                              const isBarHovered = hoveredDemSlot === barId
                              return (
                                <div
                                  key={i}
                                  className="absolute rounded flex flex-col items-center justify-center font-medium transition-all cursor-pointer"
                                  style={{
                                    left: `${(s.start/maxEnd)*100}%`,
                                    width: `${(s.duration/maxEnd)*100}%`,
                                    top: isBarHovered ? 0 : 4,
                                    height: isBarHovered ? '40px' : '24px',
                                    background: '#2563eb',
                                    zIndex: isBarHovered ? 50 : 1
                                  }}
                                  onMouseEnter={() => setHoveredDemSlot(barId)}
                                  onMouseLeave={() => setHoveredDemSlot(null)}
                                  title={`${s.sub_op} - ${getShortCustomerName(s.order_id)}\nStart: ${s.start.toFixed(1)}m\nDauer: ${s.duration.toFixed(1)}m\nEnde: ${s.end.toFixed(1)}m`}
                                >
                                  {isBarHovered && (
                                    <>
                                      <span className="text-[10px] text-black font-semibold bg-white/95 px-1 rounded leading-tight">
                                        {getShortCustomerName(s.order_id)}
                                      </span>
                                      <span className="text-[9px] text-black font-medium bg-white/95 px-1 rounded leading-tight mt-0.5">
                                        {s.sub_op}
                                      </span>
                                    </>
                                  )}
                                </div>
                              )
                            })}
                          </div>
                        </div>
                      )
                    })}
                  </div>
                )
              } catch (e) {
                console.error('Demontage slot gantt render error', e)
                return <div className="text-sm text-red-500">Fehler beim Rendern des Demontage-Slot-Gantt.</div>
              }
            })()}
          </CardContent>
        </Card>

        {/* Montage Slot Capacity Gantt */}
        <Card>
          <CardHeader>
            <CardTitle>Montage Slot Capacity</CardTitle>
          </CardHeader>
          <CardContent key={`mon-slot-gantt-${ganttRefreshKey}`}>
            {(() => {
              try {
                const events = [...simEventsRef.current]
                const starts: Record<string, { t:number; activity:string; order_id:string }> = {}
                const segs: Array<{ slot:number; sub_op:string; order_id:string; start:number; end:number; duration:number }>=[]

                // Filter for MONTAGE events with slots
                for (const ev of events) {
                  const act = ev.activity
                  if (typeof act !== 'string' || !act.startsWith('MONTAGE:') || ev.slot == null) continue

                  if (act.endsWith('_START')) {
                    const stem = act.slice(0, -6)
                    const key = `${ev.order_id}|${stem}|${ev.slot}`
                    starts[key] = { t: ev.t, activity: stem, order_id: ev.order_id }
                  } else if (act.endsWith('_END')) {
                    const stem = ev.activity.slice(0, -4)
                    const key = `${ev.order_id}|${stem}|${ev.slot}`
                    const s = starts[key]
                    if (s && ev.slot != null) {
                      const sub = stem.split(':')[1] || stem
                      segs.push({ slot: ev.slot, sub_op: sub, order_id: ev.order_id, start: s.t, end: ev.t, duration: Math.max(0, ev.t - s.t) })
                      delete starts[key]
                    }
                  }
                }

                if (segs.length === 0) return <div className="text-sm text-muted-foreground">Noch keine Montage-Slot-Operationen erfasst.</div>

                const maxEnd = Math.max(...segs.map(s => s.end)) || 1
                const slotGroups: Record<number, typeof segs> = {}
                segs.forEach(s => { (slotGroups[s.slot] ||= []).push(s) })
                Object.values(slotGroups).forEach(arr => arr.sort((a,b)=> a.start - b.start))

                // Helper: Get shortened customer name
                const getShortCustomerName = (orderId: string) => {
                  const order = activeOrders.find(o => o.id === orderId) || completedOrders.find(o => o.id === orderId)
                  if (order?.kundeName) {
                    const parts = order.kundeName.split(' ')
                    if (parts.length >= 2) return `${parts[0].charAt(0)}.${parts[1].charAt(0)}.`
                    return order.kundeName.substring(0, 4)
                  }
                  return orderId.slice(-4)
                }

                const slotIndices = Object.keys(slotGroups).map(Number).sort((a,b)=>a-b)

                return (
                  <div className="space-y-2">
                    {slotIndices.map(slotIdx => {
                      const arr = slotGroups[slotIdx]
                      return (
                        <div key={slotIdx} className="relative border rounded p-2 bg-white">
                          <div className="absolute -left-1 -top-2 text-[10px] font-mono bg-green-100 px-1 rounded border text-green-700">
                            Slot {slotIdx}
                          </div>
                          <div className="relative h-10 w-full">
                            {arr.map((s,i) => {
                              const barId = `mon-${slotIdx}-${i}`
                              const isBarHovered = hoveredMonSlot === barId
                              return (
                                <div
                                  key={i}
                                  className="absolute rounded flex flex-col items-center justify-center font-medium transition-all cursor-pointer"
                                  style={{
                                    left: `${(s.start/maxEnd)*100}%`,
                                    width: `${(s.duration/maxEnd)*100}%`,
                                    top: isBarHovered ? 0 : 4,
                                    height: isBarHovered ? '40px' : '24px',
                                    background: '#16a34a',
                                    zIndex: isBarHovered ? 50 : 1
                                  }}
                                  onMouseEnter={() => setHoveredMonSlot(barId)}
                                  onMouseLeave={() => setHoveredMonSlot(null)}
                                  title={`${s.sub_op} - ${getShortCustomerName(s.order_id)}\nStart: ${s.start.toFixed(1)}m\nDauer: ${s.duration.toFixed(1)}m\nEnde: ${s.end.toFixed(1)}m`}
                                >
                                  {isBarHovered && (
                                    <>
                                      <span className="text-[10px] text-black font-semibold bg-white/95 px-1 rounded leading-tight">
                                        {getShortCustomerName(s.order_id)}
                                      </span>
                                      <span className="text-[9px] text-black font-medium bg-white/95 px-1 rounded leading-tight mt-0.5">
                                        {s.sub_op}
                                      </span>
                                    </>
                                  )}
                                </div>
                              )
                            })}
                          </div>
                        </div>
                      )
                    })}
                  </div>
                )
              } catch (e) {
                console.error('Montage slot gantt render error', e)
                return <div className="text-sm text-red-500">Fehler beim Rendern des Montage-Slot-Gantt.</div>
              }
            })()}
          </CardContent>
        </Card>

        {/* Slot Grid (Beta) */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <Card>
            <CardHeader>
              <CardTitle>DEM Slots</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="flex flex-wrap gap-2">
                {demSlotsRef.current.map((s, i) => (
                  <div key={i} className={`px-2 py-1 rounded text-xs border ${s.busy ? 'bg-blue-600 text-white border-blue-700' : 'bg-gray-100 text-gray-700 border-gray-200'}`}>
                    #{i+1} {s.flex ? 'F' : 'R'}{s.specialization ? `:${s.specialization}` : ''}
                  </div>
                ))}
                {demSlotsRef.current.length === 0 && (
                  <div className="text-sm text-muted-foreground">Keine Slots initialisiert</div>
                )}
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardHeader>
              <CardTitle>MON Slots</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="flex flex-wrap gap-2">
                {monSlotsRef.current.map((s, i) => (
                  <div key={i} className={`px-2 py-1 rounded text-xs border ${s.busy ? 'bg-green-600 text-white border-green-700' : 'bg-gray-100 text-gray-700 border-gray-200'}`}>
                    #{i+1} {s.flex ? 'F' : 'R'}{s.specialization ? `:${s.specialization}` : ''}
                  </div>
                ))}
                {monSlotsRef.current.length === 0 && (
                  <div className="text-sm text-muted-foreground">Keine Slots initialisiert</div>
                )}
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 xl:grid-cols-4 gap-4 h-full">
      {/* Main Content - Left Side */}
      <div className="xl:col-span-3 space-y-4">
        {/* Control Panel */}
        <Card>
          <CardContent className="py-3">
            <div className="flex flex-col gap-3">
              {/* First Row: Control Buttons and Speed/Time */}
              <div className="flex items-center justify-between gap-4 flex-wrap">
                {/* Control Buttons */}
                <div className="flex items-center gap-2">
                  <Button
                  onClick={() => {
                    if (!isRunning && !simulationStartTime) {
                      // Only set start time on FIRST start, not on resume
                      // Use current simulationTime as the start time to ensure they're synchronized
                      setSimulationStartTime(simulationTime);
                      console.log('Simulation FIRST start at:', simulationTime.toISOString());
                    } else if (!isRunning) {
                      console.log('Simulation resumed, keeping original start time');
                    }
                    setIsRunning(!isRunning);
                  }}
                  className={isRunning ? "" : "bg-blue-600 hover:bg-blue-700"}
                  variant={isRunning ? "destructive" : "default"}
                >
                  {isRunning ? (
                    <>
                      <Pause className="h-4 w-4 mr-2" />
                      Pause
                    </>
                  ) : (
                    <>
                      <Play className="h-4 w-4 mr-2" />
                      Start
                    </>
                  )}
                </Button>
                
                <Button
                  onClick={() => {
                    setIsRunning(false);
                    setActiveOrders([]);
                    setCompletedOrders([]);
                    setSimulationTime(new Date());
                    setSimulationStartTime(null); // Clear start time so next start is a fresh start
                    console.log('Simulation STOPPED and RESET');
                  }}
                  variant="outline"
                  size="sm"
                >
                  <Square className="h-4 w-4 mr-1" />
                  Stop
                </Button>
                
                <Button
                  onClick={loadSimulationData}
                  variant="outline"
                  size="sm"
                >
                  <RefreshCw className="h-4 w-4 mr-1" />
                  Neu laden
                </Button>
                
                <Button
                  onClick={handleCreateNewOrder}
                  className="bg-blue-600 hover:bg-blue-700"
                  disabled={!activeFactory}
                  size="sm"
                >
                  <Plus className="h-4 w-4 mr-1" />
                  Neuer Auftrag
                </Button>
                
                <Button
                  onClick={handleClearAllOrders}
                  className="bg-white text-[#1a48a5] border-[#1a48a5] hover:bg-[#1a48a5]/5"
                  variant="outline"
                  disabled={activeOrders.length === 0 && completedOrders.length === 0}
                  size="sm"
                >
                  <Trash2 className="h-4 w-4 mr-1" />
                  Alle Aufträge löschen
                </Button>
                
                <Button
                  onClick={() => setCurrentView('kpi')}
                  className="bg-green-600 hover:bg-green-700"
                  size="sm"
                >
                  <BarChart3 className="h-4 w-4 mr-1" />
                  Data
                </Button>
              </div>
              
              {/* Speed and Time Controls */}
              <div className="flex items-center gap-6">
                <div className="flex items-center gap-2">
                  <Label className="text-sm">Geschwindigkeit:</Label>
                  <Slider
                    value={[speed]}
                    onValueChange={handleSpeedChange}
                    min={1}
                    max={100}
                    step={1}
                    className="w-24"
                  />
                  <span className="text-sm font-medium w-8">{speed}x</span>
                </div>
                
                <div className="flex items-center gap-2">
                  <Clock className="h-4 w-4" />
                  <span className="font-mono text-sm">
                    {simulationTime.toLocaleString('de-DE')}
                  </span>
                </div>
              </div>
              
              {/* Phase Capacity & Flexibility */}
              <div className="flex items-center gap-6 flex-wrap">
                <div className="flex items-center gap-2">
                  <Label className="text-sm">DEM Slots</Label>
                  <Input
                    type="number"
                    className="w-20 h-8"
                    min={0}
                    max={50}
                    value={demSlots}
                    onChange={(e) => setDemSlots(Math.max(0, Number(e.target.value)))}
                  />
                </div>
                <div className="flex items-center gap-2">
                  <Label className="text-sm">MON Slots</Label>
                  <Input
                    type="number"
                    className="w-20 h-8"
                    min={0}
                    max={50}
                    value={monSlots}
                    onChange={(e) => setMonSlots(Math.max(0, Number(e.target.value)))}
                  />
                </div>
                <div className="flex items-center gap-2">
                  <Label className="text-sm">DEM Flex</Label>
                  <div className="flex items-center gap-2">
                    <Slider
                      value={[demFlexSharePct]}
                      onValueChange={(v) => setDemFlexSharePct(v[0])}
                      min={0}
                      max={100}
                      step={5}
                      className="w-40"
                    />
                    <span className="text-sm w-10 text-muted-foreground">{demFlexSharePct}%</span>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  <Label className="text-sm">MON Flex</Label>
                  <div className="flex items-center gap-2">
                    <Slider
                      value={[monFlexSharePct]}
                      onValueChange={(v) => setMonFlexSharePct(v[0])}
                      min={0}
                      max={100}
                      step={5}
                      className="w-40"
                    />
                    <span className="text-sm w-10 text-muted-foreground">{monFlexSharePct}%</span>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  <Label className="text-sm">Setup (h)</Label>
                  <Input
                    type="number"
                    className="w-20 h-8"
                    min={0}
                    max={12}
                    step={0.5}
                    value={setupTimeHours}
                    onChange={(e) => setSetupTimeHours(Math.max(0, Number(e.target.value)))}
                  />
                </div>
                {/* Aggregated view is always on in the new simulation logic */}
              </div>

              {/* Debug Info Panel */}
              <div className="bg-yellow-50 border border-yellow-200 rounded p-3" key={debugRefreshKey}>
                <div className="text-xs font-bold text-yellow-900 mb-2">🔍 Debug Info (Live)</div>

                <div className="mb-3 border-2 border-red-600 bg-red-50 p-3 rounded">
                  <div className="text-sm font-bold text-red-900 mb-2">⚠️ PROBLEM DIAGNOSTICS</div>
                  <div className="text-xs text-red-900 space-y-2 bg-white p-2 rounded">
                    <div><strong>DEM Queue:</strong> {demQueueRef.current.length} (SOLLTE &gt; 0 SEIN!)</div>
                    <div><strong>MON Queue:</strong> {monQueueRef.current.length}</div>
                    <div><strong>DEM Ready:</strong> {demReadySetRef.current.size} Aufträge warten</div>
                    <div><strong>Active Orders:</strong> {activeOrders.length}</div>
                    {initError && (
                      <div className="border-t pt-2 mt-2 bg-red-100 p-2 rounded">
                        <strong className="text-red-900">🚨 INIT ERROR:</strong>
                        <div className="font-mono text-[10px] text-red-800 mt-1">{initError}</div>
                      </div>
                    )}
                    <div className="border-t pt-2 mt-2">
                      <strong>Initialization Logs ({initDebugLogs.length} total):</strong>
                      <div className="mt-1 max-h-32 overflow-y-auto font-mono text-[10px] bg-yellow-50 p-2 rounded">
                        {initDebugLogs.length > 0 ? (
                          initDebugLogs.map((log, i) => (
                            <div key={i} className={i < 3 ? 'font-bold text-red-800' : 'text-gray-700'}>{log}</div>
                          ))
                        ) : (
                          <div className="text-red-600 font-bold">❌ KEINE LOGS! initDebugLogs ist LEER!</div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>

                <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs mb-3">
                  <div>
                    <span className="font-semibold">DEM Queue:</span> {demQueueRef.current.length}
                  </div>
                  <div>
                    <span className="font-semibold">MON Queue:</span> {monQueueRef.current.length}
                  </div>
                  <div>
                    <span className="font-semibold">DEM Active:</span> {demActivesRef.current.length}
                  </div>
                  <div>
                    <span className="font-semibold">MON Active:</span> {monActivesRef.current.length}
                  </div>
                  <div>
                    <span className="font-semibold">DEM Ready:</span> {demReadySetRef.current.size}
                  </div>
                  <div>
                    <span className="font-semibold">Main Queues:</span> A:{mainQueuesRef.current.acceptance.length} I:{mainQueuesRef.current.inspection.length} D:{mainQueuesRef.current.demWait.length} Q:{mainQueuesRef.current.quality.length} S:{mainQueuesRef.current.shipping.length}
                  </div>
                  <div className="col-span-2">
                    <span className="font-semibold">DEM Queue IDs:</span> {demQueueRef.current.map(b => `${b.orderId.slice(-4)}(${b.ops.length}ops)`).join(', ') || 'empty'}
                  </div>
                  <div className="col-span-2">
                    <span className="font-semibold">DEM Active:</span> {demActivesRef.current.map(a => `${a.orderId.slice(-4)}@slot${a.slotIdx}(${a.remaining.toFixed(1)}/${a.total}min)`).join(', ') || 'none'}
                  </div>
                  <div className="col-span-4">
                    <span className="font-semibold">Orders @ Demontage:</span> {activeOrders.filter(o => o.currentStation === 'demontage').map(o => `${(o as any).kundeName?.slice(0,10)}(${o.progress.toFixed(0)}%)`).join(', ') || 'none'}
                  </div>
                  <div className="col-span-4 border-t pt-2 mt-2">
                    <div className="font-semibold mb-1">🔧 Dispatcher Debug:</div>
                    <div className="text-[10px] space-y-1">
                      <div>Current Sim Time: {getSimMinutes()} minutes (Speed: {speed}x, Setup: {setupTimeHours}h = {Math.round(setupTimeHours * 60)}min)</div>
                      <div>DEM Slots: {demSlotsRef.current.length} ({demSlotsRef.current.filter(s => s.busy).length} busy)</div>
                      <div>Slot Details: {demSlotsRef.current.map((s, i) => `S${i}:${s.busy?'B':'F'}${s.flex?'flex':'rigid'}${s.specialization?`(${normalizeOperationKey(s.specialization)})`:''}`).join(' ')}</div>
                      <div>Simulation Running: {isRunning ? 'YES' : 'NO'}</div>
                      <div>Aggregate View: {aggregateView ? 'YES' : 'NO'}</div>
                      <div className="mt-2 border-t pt-2">
                        <div className="font-semibold">Last Dispatcher Attempts:</div>
                        <div className="max-h-20 overflow-y-auto bg-gray-100 p-1 rounded mt-1">
                          {dispatcherLogsRef.current.slice(-10).map((log, i) => (
                            <div key={i} className="text-[9px]">{log}</div>
                          ))}
                          {dispatcherLogsRef.current.length === 0 && <div className="text-gray-500">No logs yet</div>}
                        </div>
                      </div>
                      <div className="mt-2 border-t pt-2">
                        <div className="font-semibold">Last pickSlot Debug:</div>
                        <div className="max-h-40 overflow-y-auto bg-red-50 p-1 rounded mt-1 font-mono">
                          {pickSlotDebugLogsRef.current.map((log, i) => (
                            <div key={i} className="text-[9px] whitespace-pre">{log}</div>
                          ))}
                          {pickSlotDebugLogsRef.current.length === 0 && <div className="text-gray-500">No logs yet</div>}
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              </div>

              {/* Second Row: Algorithm Dropdowns */}
              <div className="flex items-center gap-4">
                {/* Terminierung Dropdown */}
                <div className="flex items-center gap-2">
                  <Label className="text-sm font-medium">Terminierung:</Label>
                  <Select
                    value={currentSchedulingAlgorithm}
                    onValueChange={(value: SchedulingAlgorithm | string) => {
                      if (value in SchedulingAlgorithm) {
                        setCurrentSchedulingAlgorithm(value as SchedulingAlgorithm);
                      }
                    }}
                  >
                    <SelectTrigger className="w-[200px]">
                      <SelectValue placeholder="Wähle Algorithmus" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value={SchedulingAlgorithm.FIFO}>
                        FIFO - First In First Out
                      </SelectItem>
                      <SelectItem value="empty1" disabled>
                        --- Leer ---
                      </SelectItem>
                      <SelectItem value="empty2" disabled>
                        --- Leer ---
                      </SelectItem>
                      <SelectItem value="empty3" disabled>
                        --- Leer ---
                      </SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                
                {/* Beschaffungsplanung Dropdown */}
                <div className="flex items-center gap-2">
                  <Label className="text-sm font-medium">Beschaffungsplanung:</Label>
                  <Select
                    value="none"
                    disabled
                  >
                    <SelectTrigger className="w-[200px]">
                      <SelectValue placeholder="Wähle Algorithmus" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="none" disabled>
                        --- Leer ---
                      </SelectItem>
                      <SelectItem value="empty1" disabled>
                        --- Leer ---
                      </SelectItem>
                      <SelectItem value="empty2" disabled>
                        --- Leer ---
                      </SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Statistics */}
        <div className="grid grid-cols-5 gap-4">
          <Card>
            <CardContent className="pt-4">
              <div className="text-xl font-bold">{activeOrders.length}</div>
              <p className="text-xs text-muted-foreground">Aktive Aufträge</p>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="pt-4">
              <div className="text-xl font-bold">{waitingOrders.length}</div>
              <p className="text-xs text-muted-foreground">Wartende Aufträge</p>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="pt-4">
              <div className="text-xl font-bold">{completedOrders.length}</div>
              <p className="text-xs text-muted-foreground">Abgeschlossen</p>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="pt-4">
              <div className="text-xl font-bold">{stations.length}</div>
              <p className="text-xs text-muted-foreground">Stationen</p>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="pt-4">
              <div className="text-xl font-bold">
                {stations.filter(s => s.currentOrder !== null).length}
              </div>
              <p className="text-xs text-muted-foreground">Stationen belegt</p>
            </CardContent>
          </Card>
        </div>

        {/* Process Flow Diagram */}
        <Card>
          <CardHeader>
            <CardTitle>Prozessfluss</CardTitle>
          </CardHeader>
          <CardContent>
            <div style={{ height: 400 }}>
              <ReactFlow
                nodes={nodes}
                edges={edges}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                onNodeClick={(_, node) => handleStationClick(node.id)}
                fitView
                defaultViewport={{ x: 0, y: 0, zoom: 1 }}
                minZoom={0.5}
                maxZoom={2}
                style={{ width: '100%', height: '100%' }}
                nodeTypes={nodeTypes}
              >
                <Background />
                <Controls />
                <MiniMap />
              </ReactFlow>
            </div>
          </CardContent>
        </Card>

        {/* Active Orders List */}
        <Card>
          <CardHeader>
            <CardTitle>Aktive Aufträge - Prozesszeiten</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              {activeOrders.length === 0 ? (
                <p className="text-center text-gray-500 py-8">Keine aktiven Aufträge</p>
              ) : (
                <>
                  {/* Summary Table */}
                  <div className="rounded-md border">
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead className="w-[150px]">Kunde</TableHead>
                          <TableHead className="w-[200px]">Produktvariante</TableHead>
                          <TableHead className="w-[150px]">Aktuelle Station</TableHead>
                          <TableHead className="w-[120px]">Fortschritt</TableHead>
                          <TableHead className="w-[100px]">Verzögerung</TableHead>
                          <TableHead className="w-[100px]">Gesamtzeit</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {activeOrders.map((order) => {
                          const currentStationData = stations.find(s => s.id === order.currentStation);
                          const currentStationDuration = order.stationDurations[order.currentStation];
                          const progressPercent = (order.progress / (currentStationDuration?.actual || currentStationData?.processingTime || 1)) * 100;
                          
                          // Calculate total delay across all completed stations
                          const completedStations = Object.entries(order.stationDurations).filter(([stationId, duration]) => {
                            return duration.actual && order.processSequence.indexOf(order.currentStation) > order.processSequence.indexOf(stationId);
                          });
                          const totalDelay = completedStations.reduce((acc, [, duration]) => {
                            return acc + (duration.actual! - duration.expected);
                          }, 0);
                          
                          // Calculate total time spent so far
                          const totalTimeSpent = completedStations.reduce((acc, [, duration]) => acc + duration.actual!, 0) + order.progress;
                          
                          return (
                            <TableRow key={order.id}>
                              <TableCell className="font-medium">{order.kundeName}</TableCell>
                              <TableCell>{order.produktvariante}</TableCell>
                              <TableCell>
                                <span className="px-2 py-1 bg-blue-100 text-blue-800 rounded text-xs font-medium">
                                  {currentStationData?.name || 'Unbekannt'}
                                </span>
                              </TableCell>
                              <TableCell>
                                <div className="flex items-center space-x-2">
                                  <div className="w-16 bg-gray-200 rounded-full h-2">
                                    <div 
                                      className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                                      style={{ width: `${Math.min(100, progressPercent)}%` }}
                                    ></div>
                                  </div>
                                  <span className="text-xs font-medium">{progressPercent.toFixed(0)}%</span>
                                </div>
                              </TableCell>
                              <TableCell>
                                <span className={`text-xs font-medium ${
                                  totalDelay > 0 ? 'text-red-600' : totalDelay < 0 ? 'text-green-600' : 'text-gray-600'
                                }`}>
                                  {totalDelay > 0 ? '+' : ''}{totalDelay.toFixed(1)} min
                                </span>
                              </TableCell>
                              <TableCell className="text-xs font-medium">
                                {totalTimeSpent.toFixed(1)} min
                              </TableCell>
                            </TableRow>
                          );
                        })}
                      </TableBody>
                    </Table>
                  </div>
                </>
              )}
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Analytics Sidebar - Right Side */}
      <div className="xl:col-span-1 space-y-4">
        {/* Order Time Distribution Chart */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Zeitverteilung pro Auftrag</CardTitle>
          </CardHeader>
          <CardContent>
            {completedOrders.length === 0 ? (
              <div className="flex items-center justify-center h-[300px] text-center">
                <p className="text-gray-500 text-sm">
                  Noch keine abgeschlossenen Aufträge für die Zeitverteilung verfügbar
                </p>
              </div>
            ) : (
              <ResponsiveContainer width="100%" height={300}>
                <BarChart 
                  data={prepareChartData()} 
                  margin={{ top: 20, right: 5, left: 5, bottom: 80 }}
                >
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis 
                    dataKey="name" 
                    angle={-45}
                    textAnchor="end"
                    height={80}
                    interval={0}
                    fontSize={9}
                  />
                  <YAxis 
                    label={{ value: 'Zeit (min)', angle: -90, position: 'insideLeft' }}
                    fontSize={9}
                  />
                  <Tooltip 
                    formatter={(value: number, name: string) => [`${value} min`, name]}
                    labelFormatter={(label) => `Kunde: ${label}`}
                  />
                  <Legend />
                  <Bar dataKey="Bearbeitungszeit" stackId="a" fill="#82ca9d" name="Bearbeitungszeit" />
                  <Bar dataKey="Wartezeit" stackId="a" fill="#ffc658" name="Wartezeit" />
                </BarChart>
              </ResponsiveContainer>
            )}
          </CardContent>
        </Card>

        {/* Station Utilization Display */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Stationsauslastung</CardTitle>
          </CardHeader>
          <CardContent>
            {(() => {
              try {
                if (!stations || stations.length === 0) {
                  return (
                    <div className="flex items-center justify-center h-[200px] text-center">
                      <p className="text-gray-500 text-sm">
                        Keine Stationen konfiguriert
                      </p>
                    </div>
                  );
                }
                
                // Ensure we have the required context values
                if (typeof simulationTime === 'undefined' || typeof simulationStartTime === 'undefined') {
                  return (
                    <div className="flex items-center justify-center h-[200px] text-center">
                      <p className="text-gray-500 text-sm">
                        Simulation wird initialisiert...
                      </p>
                    </div>
                  );
                }

              // Get all SUB stations directly with safe filtering - excluding demontage waiting queue
              const demontageStations = stations.filter(s => {
                try {
                  return (s?.id?.includes('demontage-') || (s?.type === 'SUB' && s?.parent === 'demontage')) 
                    && s?.id !== 'demontage-waiting'; // Exclude the waiting queue
                } catch (e) {
                  console.warn('Error filtering demontage station:', s, e);
                  return false;
                }
              });
              
              const reassemblyStations = stations.filter(s => {
                try {
                  return s?.id?.includes('reassembly-') || (s?.type === 'SUB' && s?.parent === 'reassembly');
                } catch (e) {
                  console.warn('Error filtering reassembly station:', s, e);
                  return false;
                }
              });
              
              const allSubStations = [...demontageStations, ...reassemblyStations];
              
              if (allSubStations.length === 0) {
                return (
                  <div className="flex items-center justify-center h-[200px] text-center">
                    <div>
                      <p className="text-gray-500 text-sm mb-2">
                        Keine Unter-Stationen gefunden
                      </p>
                      <p className="text-xs text-gray-400">
                        {stations.length} Stationen verfügbar, aber keine SUB-Stationen
                      </p>
                    </div>
                  </div>
                );
              }

              // Skip utilization calculation if simulation hasn't started
              if (!simulationStartTime) {
                return (
                  <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                    {allSubStations.slice(0, 12).map((station, index) => (
                      <div
                        key={station.id || `station-${index}`}
                        className="p-1 border rounded bg-gray-50"
                      >
                        <div className="text-[7px] font-medium text-gray-600 leading-tight">
                          {(station.id?.includes('demontage') || station.parent === 'demontage') ? 'Disassembly' : 'Assembly'}
                        </div>
                        <div className="text-[8px] font-semibold text-gray-800 leading-tight truncate" title={station.name || 'Unknown Station'}>
                          {station.name || 'Unknown'}
                        </div>
                        <div className="text-[10px] text-gray-400 mt-1">
                          0%
                        </div>
                      </div>
                    ))}
                  </div>
                );
              }
              
              // Calculate utilization for each station
              const currentTime = simulationTime.getTime();
              const startTime = simulationStartTime.getTime();
              const simulationDurationMs = Math.max(currentTime - startTime, 1000); // At least 1 second
              const simulationDurationMinutes = simulationDurationMs / (1000 * 60);
              
              // Debug logging to track timing
              console.log('Utilization calculation timing:', {
                currentTime: new Date(currentTime).toISOString(),
                startTime: new Date(startTime).toISOString(),
                durationMinutes: simulationDurationMinutes.toFixed(2),
                isRunning
              });

              return (
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                  {allSubStations.slice(0, 12).map((station, index) => {
                    try {
                      if (!station || !station.id) {
                        return (
                          <div key={`unknown-${index}`} className="p-3 border rounded-lg bg-gray-50">
                            <div className="text-xs text-gray-500">Unknown Station</div>
                          </div>
                        );
                      }

                      // Calculate CUMULATIVE processing time - avoiding double counting
                      let totalProcessingTime = 0;
                      
                      // Track which orders we've already counted to avoid double counting
                      const countedOrders = new Set<string>();
                      
                      // Add time from completed orders
                      (completedOrders || []).forEach((order: any) => {
                        try {
                          const stationDuration = order?.stationDurations?.[station.id];
                          if (stationDuration?.actual && !countedOrders.has(order.id)) {
                            totalProcessingTime += stationDuration.actual;
                            countedOrders.add(order.id);
                          }
                        } catch (e) {
                          console.warn('Error calculating processing time for completed order:', order?.id, e);
                        }
                      });

                      // Add time from active orders - either current progress OR completed time, not both
                      (activeOrders || []).forEach((order: any) => {
                        try {
                          if (countedOrders.has(order.id)) return; // Skip if already counted
                          
                          const stationDuration = order?.stationDurations?.[station.id];
                          
                          if (stationDuration?.completed && stationDuration?.actual) {
                            // Order has passed through this station - count the completed time
                            totalProcessingTime += stationDuration.actual;
                            countedOrders.add(order.id);
                          } else if (order?.currentStation === station.id && !order?.isWaiting) {
                            // Order is currently processing at this station - count current progress
                            totalProcessingTime += (order?.progress || 0);
                            countedOrders.add(order.id);
                          }
                        } catch (e) {
                          console.warn('Error calculating active processing time for order:', order?.id, e);
                        }
                      });
                      
                      // Enhanced debugging for troubleshooting
                      if (totalProcessingTime > 0) {
                        console.log(`Station ${station.id} (${station.name}):`, {
                          totalProcessingTime: totalProcessingTime.toFixed(1),
                          simulationDurationMinutes: simulationDurationMinutes.toFixed(1),
                          countedOrders: countedOrders.size,
                          utilizationRate: ((totalProcessingTime / simulationDurationMinutes) * 100).toFixed(1) + '%'
                        });
                      }
                      
                      if (totalProcessingTime > simulationDurationMinutes) {
                        console.error(`🚨 IMPOSSIBLE UTILIZATION: Station ${station.id}:`, {
                          totalProcessingTime: totalProcessingTime.toFixed(1) + 'min',
                          simulationDuration: simulationDurationMinutes.toFixed(1) + 'min',
                          countedOrders: Array.from(countedOrders),
                          ratio: ((totalProcessingTime / simulationDurationMinutes) * 100).toFixed(1) + '%'
                        });
                      }

                      // Pure mathematical calculation: cumulative processing time / total simulation time
                      // Capped at 100% to prevent display issues
                      const utilizationRate = simulationDurationMinutes > 0 
                        ? Math.min((totalProcessingTime / simulationDurationMinutes) * 100, 100)
                        : 0;

                      const stationType = (station.id?.includes('demontage') || station.parent === 'demontage') ? 'Disassembly' : 'Assembly';
                      const isActive = station.currentOrder !== null;

                      return (
                        <div 
                          key={station.id} 
                          className={`p-1 border rounded ${isActive ? 'bg-blue-50 border-blue-200' : 'bg-gray-50'}`}
                        >
                          <div className="text-[7px] font-medium text-gray-600 leading-tight">
                            {stationType}
                          </div>
                          <div className="text-[8px] font-semibold text-gray-800 leading-tight truncate" title={station.name || 'Unknown Station'}>
                            {station.name || 'Unknown'}
                          </div>
                          <div className="flex items-center justify-between mt-1">
                            <div className={`text-[10px] font-bold ${utilizationRate >= 70 ? 'text-green-600' : utilizationRate >= 50 ? 'text-blue-600' : utilizationRate >= 30 ? 'text-orange-600' : 'text-red-600'}`}>
                              {(utilizationRate || 0).toFixed(1)}%
                            </div>
                            <div className="text-[7px] text-gray-500">
                              {isActive ? 'A' : 'F'}
                            </div>
                          </div>
                        </div>
                      );
                    } catch (e) {
                      console.error('Error rendering station:', station?.id, e);
                      return (
                        <div key={`error-${index}`} className="p-3 border rounded-lg bg-red-50">
                          <div className="text-xs text-red-600">Station Error</div>
                        </div>
                      );
                    }
                  })}
                </div>
              );
              } catch (error) {
                console.error('Error in Stationsauslastung component:', error);
                return (
                  <div className="flex items-center justify-center h-[200px] text-center">
                    <div>
                      <p className="text-red-500 text-sm mb-2">
                        Fehler beim Laden der Stationsauslastung
                      </p>
                      <p className="text-xs text-gray-400">
                        Überprüfen Sie die Browser-Konsole für Details
                      </p>
                    </div>
                  </div>
                );
              }
            })()}
          </CardContent>
        </Card>

        {/* Placeholder for Future Changeover Times Chart */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Rüstzeiten</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center justify-center h-[300px] text-center">
              <p className="text-gray-500 text-sm">
                Kommende Funktionalität:<br/>
                Durchschnittliche Rüstzeiten<br/>
                pro Station
              </p>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Station Configuration Dialog */}
      <Dialog open={stationDialogOpen} onOpenChange={setStationDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Station konfigurieren: {selectedStation?.name}</DialogTitle>
            <DialogDescription>
              Passen Sie die Bearbeitungszeit für diese Station an.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="processing-time" className="text-right">
                Bearbeitungszeit (Minuten)
              </Label>
              <Input
                id="processing-time"
                type="number"
                value={tempProcessingTime}
                onChange={(e) => setTempProcessingTime(Number(e.target.value))}
                className="col-span-3"
              />
            </div>
          </div>
          <DialogFooter>
            <Button onClick={handleSaveStationTime}>Speichern</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Inspection Configuration Dialog */}
      <Dialog open={inspectionDialogOpen} onOpenChange={setInspectionDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Inspektionseinstellungen</DialogTitle>
            <DialogDescription>
              Konfigurieren Sie den Prozentsatz der Baugruppen, die nach der Inspektion zusätzlich remontiert werden müssen.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="reassembly-percentage" className="text-right">
                Remontage-Prozentsatz (%)
              </Label>
              <div className="col-span-3 space-y-2">
                <Input
                  id="reassembly-percentage"
                  type="number"
                  min="0"
                  max="100"
                  value={reassemblyPercentage}
                  onChange={(e) => setReassemblyPercentage(Number(e.target.value))}
                />
                <p className="text-sm text-gray-500">
                  Anteil der Baugruppen, die zusätzliche Remontage benötigen: {reassemblyPercentage}%
                </p>
              </div>
            </div>
            <div className="grid grid-cols-4 items-start gap-4">
              <Label className="text-right text-sm text-gray-600">
                Erklärung:
              </Label>
              <div className="col-span-3 text-sm text-gray-600">
                <p>
                  Dieser Wert bestimmt, bei welchem Prozentsatz der Baugruppen während der Inspektion 
                  festgestellt wird, dass sie zusätzliche Remontage-Arbeiten benötigen, 
                  die nicht vor der Inspektion geplant waren.
                </p>
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button onClick={() => setInspectionDialogOpen(false)} variant="outline">
              Abbrechen
            </Button>
            <Button onClick={() => {
              // Save the setting (mock-up for now)
              toast.success(`Remontage-Prozentsatz auf ${reassemblyPercentage}% gesetzt`);
              setInspectionDialogOpen(false);
            }}>
              Speichern
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

    </div>
  );
}
